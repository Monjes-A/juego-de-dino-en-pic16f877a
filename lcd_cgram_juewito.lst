CCS PCM C Compiler, Version 5.025, 12197               08-feb.-23 14:21

               Filename:   C:\Users\LAPTOP\Documents\ESTUDIOS\universidad\Proyectos en C\juego-de-dino-en-pic16f877a\lcd_cgram_juewito.lst

               ROM used:   3173 words (39%)
                           Largest free fragment is 2048
               RAM used:   22 (6%) at main() level
                           60 (16%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... // Proyecto de Lcd , Tercera  practica. realizado por Mi . Jesus Monsalve 
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA A0,26
0005:  DATA 69,37
0006:  DATA 69,10
0007:  DATA C4,34
0008:  DATA EE,37
0009:  DATA A0,3B
000A:  DATA AE,3B
000B:  DATA A0,10
000C:  DATA 00,00
000D:  DATA 20,28
000E:  DATA D2,22
000F:  DATA D3,22
0010:  DATA 4E,2A
0011:  DATA 41,22
0012:  DATA 4F,10
0013:  DATA D0,27
0014:  DATA D2,10
0015:  DATA 00,01
0016:  DATA CA,22
0017:  DATA D3,2A
0018:  DATA 53,10
0019:  DATA 41,10
001A:  DATA CD,27
001B:  DATA CE,29
001C:  DATA 41,26
001D:  DATA D6,22
001E:  DATA 00,01
001F:  DATA 20,10
0020:  DATA 20,10
0021:  DATA 20,2D
0022:  DATA 45,29
0023:  DATA D0,20
0024:  DATA 2E,10
0025:  DATA 20,10
0026:  DATA 20,10
0027:  DATA 00,01
0028:  DATA 20,10
0029:  DATA 20,27
002A:  DATA 4F,10
002B:  DATA CD,20
002C:  DATA D4,22
002D:  DATA 53,10
002E:  DATA 41,26
002F:  DATA 20,10
0030:  DATA 00,01
0031:  DATA 20,10
0032:  DATA 20,22
0033:  DATA 49,27
0034:  DATA CF,29
0035:  DATA C1,2A
0036:  DATA D2,24
0037:  DATA 4F,17
0038:  DATA 20,10
0039:  DATA 00,01
003A:  DATA C4,20
003B:  DATA CC,22
003C:  DATA A0,20
003D:  DATA 4C,10
003E:  DATA C2,27
003F:  DATA D4,27
0040:  DATA CE,10
0041:  DATA A1,10
0042:  DATA 00,01
0043:  DATA 20,10
0044:  DATA 20,10
0045:  DATA 20,10
0046:  DATA 20,10
0047:  DATA 20,10
0048:  DATA 20,10
0049:  DATA 20,10
004A:  DATA 20,10
004B:  DATA 00,01
004C:  DATA D9,27
004D:  DATA A0,29
004E:  DATA 45,10
004F:  DATA 51,10
0050:  DATA D1,2A
0051:  DATA C9,22
0052:  DATA D2,22
0053:  DATA D3,10
0054:  DATA 21,00
0055:  DATA 0C,00
0056:  DATA C1,2C
0057:  DATA D9,2C
0058:  DATA 20,28
0059:  DATA 41,28
005A:  DATA C1,20
005B:  DATA A1,10
005C:  DATA 20,2C
005D:  DATA 44,00
005E:  DATA 41,29
005F:  DATA D2,20
0060:  DATA CE,21
0061:  DATA C1,26
0062:  DATA CF,29
0063:  DATA 00,01
0064:  DATA 0C,00
0065:  DATA D0,1E
0066:  DATA 00,01
0067:  DATA F5,3C
0068:  DATA 20,3C
0069:  DATA 2E,3C
006A:  DATA A0,39
006B:  DATA 65,10
006C:  DATA ED,3A
006D:  DATA F2,34
006E:  DATA 6F,10
006F:  DATA 00,01
0070:  DATA F4,3A
0071:  DATA 73,10
0072:  DATA 70,3A
0073:  DATA 73,10
0074:  DATA F0,32
0075:  DATA 72,39
0076:  DATA EF,37
0077:  DATA EF,10
0078:  DATA 00,01
0079:  DATA 20,10
007A:  DATA F5,3C
007B:  DATA 21,10
007C:  DATA 20,10
007D:  DATA AD,18
007E:  DATA 20,10
007F:  DATA F6,34
0080:  DATA E4,30
0081:  DATA 00,01
0082:  DATA 0C,00
0083:  DATA F5,3C
0084:  DATA 20,3C
0085:  DATA 2E,3C
0086:  DATA A0,39
0087:  DATA 65,10
0088:  DATA ED,3A
0089:  DATA F2,34
008A:  DATA 6F,10
008B:  DATA 00,01
008C:  DATA F4,3A
008D:  DATA 73,10
008E:  DATA 70,3A
008F:  DATA 73,10
0090:  DATA F0,32
0091:  DATA 72,39
0092:  DATA EF,37
0093:  DATA EF,10
0094:  DATA 00,01
0095:  DATA 20,10
0096:  DATA F5,3C
0097:  DATA 21,10
0098:  DATA 20,10
0099:  DATA AD,18
009A:  DATA 20,10
009B:  DATA F6,34
009C:  DATA E4,30
009D:  DATA 00,01
009E:  DATA 0C,00
009F:  DATA F5,3C
00A0:  DATA 20,3C
00A1:  DATA 2E,3C
00A2:  DATA A0,39
00A3:  DATA 65,10
00A4:  DATA ED,3A
00A5:  DATA F2,34
00A6:  DATA 6F,10
00A7:  DATA 00,01
00A8:  DATA F4,3A
00A9:  DATA 73,10
00AA:  DATA 70,3A
00AB:  DATA 73,10
00AC:  DATA F0,32
00AD:  DATA 72,39
00AE:  DATA EF,37
00AF:  DATA EF,10
00B0:  DATA 00,01
00B1:  DATA 20,10
00B2:  DATA F5,3C
00B3:  DATA 21,10
00B4:  DATA 20,10
00B5:  DATA AD,18
00B6:  DATA 20,10
00B7:  DATA F6,34
00B8:  DATA E4,30
00B9:  DATA 00,01
00BA:  DATA 0C,00
*
020C:  MOVF   0B,W
020D:  MOVWF  2F
020E:  BCF    0B.7
020F:  BSF    03.5
0210:  BSF    03.6
0211:  BSF    0C.7
0212:  BSF    0C.0
0213:  NOP
0214:  NOP
0215:  BCF    03.5
0216:  BCF    03.6
0217:  BTFSC  2F.7
0218:  BSF    0B.7
0219:  BSF    03.6
021A:  MOVF   0C,W
021B:  ANDLW  7F
021C:  BTFSC  03.2
021D:  GOTO   260
021E:  BCF    03.6
021F:  MOVWF  2F
0220:  BSF    03.6
0221:  MOVF   0D,W
0222:  BCF    03.6
0223:  MOVWF  30
0224:  BSF    03.6
0225:  MOVF   0F,W
0226:  BCF    03.6
0227:  MOVWF  31
0228:  MOVF   2F,W
0229:  MOVWF  3A
022A:  CALL   1E0
022B:  MOVF   30,W
022C:  BSF    03.6
022D:  MOVWF  0D
022E:  BCF    03.6
022F:  MOVF   31,W
0230:  BSF    03.6
0231:  MOVWF  0F
0232:  BCF    03.6
0233:  MOVF   0B,W
0234:  MOVWF  32
0235:  BCF    0B.7
0236:  BSF    03.5
0237:  BSF    03.6
0238:  BSF    0C.7
0239:  BSF    0C.0
023A:  NOP
023B:  NOP
023C:  BCF    03.5
023D:  BCF    03.6
023E:  BTFSC  32.7
023F:  BSF    0B.7
0240:  BSF    03.6
0241:  RLF    0C,W
0242:  RLF    0E,W
0243:  ANDLW  7F
0244:  BTFSC  03.2
0245:  GOTO   260
0246:  BCF    03.6
0247:  MOVWF  2F
0248:  BSF    03.6
0249:  MOVF   0D,W
024A:  BCF    03.6
024B:  MOVWF  30
024C:  BSF    03.6
024D:  MOVF   0F,W
024E:  BCF    03.6
024F:  MOVWF  31
0250:  MOVF   2F,W
0251:  MOVWF  3A
0252:  CALL   1E0
0253:  MOVF   30,W
0254:  BSF    03.6
0255:  MOVWF  0D
0256:  BCF    03.6
0257:  MOVF   31,W
0258:  BSF    03.6
0259:  MOVWF  0F
025A:  INCF   0D,F
025B:  BTFSC  03.2
025C:  INCF   0F,F
025D:  BCF    03.6
025E:  GOTO   20C
025F:  BSF    03.6
0260:  BCF    03.6
0261:  RETURN
*
02C5:  BTFSC  03.1
02C6:  GOTO   2CA
02C7:  MOVLW  52
02C8:  MOVWF  04
02C9:  BCF    03.7
02CA:  CLRF   77
02CB:  CLRF   78
02CC:  CLRF   79
02CD:  CLRF   7A
02CE:  CLRF   52
02CF:  CLRF   53
02D0:  CLRF   54
02D1:  CLRF   55
02D2:  MOVF   51,W
02D3:  IORWF  50,W
02D4:  IORWF  4F,W
02D5:  IORWF  4E,W
02D6:  BTFSC  03.2
02D7:  GOTO   308
02D8:  MOVLW  20
02D9:  MOVWF  56
02DA:  BCF    03.0
02DB:  RLF    4A,F
02DC:  RLF    4B,F
02DD:  RLF    4C,F
02DE:  RLF    4D,F
02DF:  RLF    52,F
02E0:  RLF    53,F
02E1:  RLF    54,F
02E2:  RLF    55,F
02E3:  MOVF   51,W
02E4:  SUBWF  55,W
02E5:  BTFSS  03.2
02E6:  GOTO   2F1
02E7:  MOVF   50,W
02E8:  SUBWF  54,W
02E9:  BTFSS  03.2
02EA:  GOTO   2F1
02EB:  MOVF   4F,W
02EC:  SUBWF  53,W
02ED:  BTFSS  03.2
02EE:  GOTO   2F1
02EF:  MOVF   4E,W
02F0:  SUBWF  52,W
02F1:  BTFSS  03.0
02F2:  GOTO   302
02F3:  MOVF   4E,W
02F4:  SUBWF  52,F
02F5:  MOVF   4F,W
02F6:  BTFSS  03.0
02F7:  INCFSZ 4F,W
02F8:  SUBWF  53,F
02F9:  MOVF   50,W
02FA:  BTFSS  03.0
02FB:  INCFSZ 50,W
02FC:  SUBWF  54,F
02FD:  MOVF   51,W
02FE:  BTFSS  03.0
02FF:  INCFSZ 51,W
0300:  SUBWF  55,F
0301:  BSF    03.0
0302:  RLF    77,F
0303:  RLF    78,F
0304:  RLF    79,F
0305:  RLF    7A,F
0306:  DECFSZ 56,F
0307:  GOTO   2DA
0308:  MOVF   52,W
0309:  MOVWF  00
030A:  INCF   04,F
030B:  MOVF   53,W
030C:  MOVWF  00
030D:  INCF   04,F
030E:  MOVF   54,W
030F:  MOVWF  00
0310:  INCF   04,F
0311:  MOVF   55,W
0312:  MOVWF  00
0313:  RETURN
0314:  CLRF   78
0315:  CLRF   79
0316:  CLRF   77
0317:  CLRF   7A
0318:  MOVF   45,W
0319:  BTFSS  03.2
031A:  GOTO   31E
031B:  MOVF   44,W
031C:  BTFSC  03.2
031D:  GOTO   338
031E:  MOVLW  10
031F:  MOVWF  46
0320:  BCF    03.0
0321:  RLF    42,F
0322:  RLF    43,F
0323:  RLF    77,F
0324:  RLF    7A,F
0325:  MOVF   45,W
0326:  SUBWF  7A,W
0327:  BTFSS  03.2
0328:  GOTO   32B
0329:  MOVF   44,W
032A:  SUBWF  77,W
032B:  BTFSS  03.0
032C:  GOTO   334
032D:  MOVF   44,W
032E:  SUBWF  77,F
032F:  BTFSS  03.0
0330:  DECF   7A,F
0331:  MOVF   45,W
0332:  SUBWF  7A,F
0333:  BSF    03.0
0334:  RLF    78,F
0335:  RLF    79,F
0336:  DECFSZ 46,F
0337:  GOTO   320
0338:  RETURN
0339:  MOVLW  20
033A:  MOVWF  52
033B:  CLRF   4E
033C:  CLRF   4F
033D:  CLRF   50
033E:  CLRF   51
033F:  MOVF   49,W
0340:  MOVWF  7A
0341:  MOVF   48,W
0342:  MOVWF  79
0343:  MOVF   47,W
0344:  MOVWF  78
0345:  MOVF   46,W
0346:  MOVWF  77
0347:  BCF    03.0
0348:  BTFSS  77.0
0349:  GOTO   358
034A:  MOVF   4A,W
034B:  ADDWF  4E,F
034C:  MOVF   4B,W
034D:  BTFSC  03.0
034E:  INCFSZ 4B,W
034F:  ADDWF  4F,F
0350:  MOVF   4C,W
0351:  BTFSC  03.0
0352:  INCFSZ 4C,W
0353:  ADDWF  50,F
0354:  MOVF   4D,W
0355:  BTFSC  03.0
0356:  INCFSZ 4D,W
0357:  ADDWF  51,F
0358:  RRF    51,F
0359:  RRF    50,F
035A:  RRF    4F,F
035B:  RRF    4E,F
035C:  RRF    7A,F
035D:  RRF    79,F
035E:  RRF    78,F
035F:  RRF    77,F
0360:  DECFSZ 52,F
0361:  GOTO   347
0362:  RETURN
*
0393:  MOVF   42,W
0394:  ANDLW  07
0395:  MOVWF  77
0396:  RRF    42,W
0397:  MOVWF  78
0398:  RRF    78,F
0399:  RRF    78,F
039A:  MOVLW  1F
039B:  ANDWF  78,F
039C:  MOVF   78,W
039D:  ADDWF  44,W
039E:  MOVWF  04
039F:  BCF    03.7
03A0:  BTFSC  45.0
03A1:  BSF    03.7
03A2:  CLRF   78
03A3:  INCF   78,F
03A4:  INCF   77,F
03A5:  GOTO   3A7
03A6:  RLF    78,F
03A7:  DECFSZ 77,F
03A8:  GOTO   3A6
03A9:  MOVF   43,F
03AA:  BTFSC  03.2
03AB:  GOTO   3AF
03AC:  MOVF   78,W
03AD:  IORWF  00,F
03AE:  GOTO   3B2
03AF:  COMF   78,F
03B0:  MOVF   78,W
03B1:  ANDWF  00,F
03B2:  RETURN
*
04BF:  CLRF   37
04C0:  MOVF   04,W
04C1:  MOVWF  36
04C2:  BCF    37.0
04C3:  BTFSC  03.7
04C4:  BSF    37.0
04C5:  BTFSS  30.7
04C6:  GOTO   4CF
04C7:  BSF    36.7
04C8:  BTFSS  36.4
04C9:  INCF   36,F
04CA:  COMF   2F,F
04CB:  COMF   30,F
04CC:  INCF   2F,F
04CD:  BTFSC  03.2
04CE:  INCF   30,F
04CF:  SWAPF  30,W
04D0:  IORLW  F0
04D1:  MOVWF  32
04D2:  ADDWF  32,F
04D3:  ADDLW  E2
04D4:  MOVWF  33
04D5:  ADDLW  32
04D6:  MOVWF  35
04D7:  MOVF   30,W
04D8:  ANDLW  0F
04D9:  ADDWF  33,F
04DA:  ADDWF  33,F
04DB:  ADDWF  35,F
04DC:  ADDLW  E9
04DD:  MOVWF  34
04DE:  ADDWF  34,F
04DF:  ADDWF  34,F
04E0:  SWAPF  2F,W
04E1:  ANDLW  0F
04E2:  ADDWF  34,F
04E3:  ADDWF  35,F
04E4:  RLF    34,F
04E5:  RLF    35,F
04E6:  COMF   35,F
04E7:  RLF    35,F
04E8:  MOVF   2F,W
04E9:  ANDLW  0F
04EA:  ADDWF  35,F
04EB:  RLF    32,F
04EC:  MOVLW  07
04ED:  MOVWF  31
04EE:  MOVLW  0A
04EF:  ADDWF  35,F
04F0:  DECF   34,F
04F1:  BTFSS  03.0
04F2:  GOTO   4EF
04F3:  ADDWF  34,F
04F4:  DECF   33,F
04F5:  BTFSS  03.0
04F6:  GOTO   4F3
04F7:  ADDWF  33,F
04F8:  DECF   32,F
04F9:  BTFSS  03.0
04FA:  GOTO   4F7
04FB:  ADDWF  32,F
04FC:  DECF   31,F
04FD:  BTFSS  03.0
04FE:  GOTO   4FB
04FF:  MOVLW  31
0500:  MOVWF  04
0501:  BCF    03.7
0502:  MOVLW  07
0503:  ANDWF  36,W
0504:  BCF    36.6
0505:  DECF   04,F
0506:  ANDWF  36,W
0507:  BTFSS  03.2
0508:  GOTO   510
0509:  BTFSC  36.4
050A:  INCF   04,F
050B:  BTFSC  36.4
050C:  GOTO   510
050D:  MOVLW  20
050E:  MOVWF  77
050F:  GOTO   52D
0510:  ADDWF  04,F
0511:  MOVLW  35
0512:  SUBWF  04,W
0513:  BTFSC  03.2
0514:  BSF    36.6
0515:  MOVF   00,W
0516:  MOVWF  77
0517:  BTFSS  03.2
0518:  GOTO   521
0519:  BTFSC  36.6
051A:  GOTO   521
051B:  BTFSC  36.4
051C:  GOTO   53B
051D:  BTFSC  36.3
051E:  GOTO   521
051F:  MOVLW  20
0520:  GOTO   52C
0521:  BTFSS  36.7
0522:  GOTO   529
0523:  MOVLW  2D
0524:  MOVWF  77
0525:  DECF   04,F
0526:  BCF    36.6
0527:  BCF    36.7
0528:  GOTO   52D
0529:  BSF    36.3
052A:  BCF    36.4
052B:  MOVLW  30
052C:  ADDWF  77,F
052D:  CLRF   30
052E:  MOVF   04,W
052F:  MOVWF  2F
0530:  BCF    30.0
0531:  BTFSC  03.7
0532:  BSF    30.0
0533:  MOVF   77,W
0534:  MOVWF  3A
0535:  CALL   1E0
0536:  MOVF   2F,W
0537:  MOVWF  04
0538:  BCF    03.7
0539:  BTFSC  30.0
053A:  BSF    03.7
053B:  INCF   04,F
053C:  BTFSS  36.6
053D:  GOTO   511
053E:  RETURN
....................  
.................... #list 
....................  
.................... #fuses XT, NOWDT, NOPUT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOPROTECT, NODEBUG 
.................... #use delay(clock = 4000000) 
*
00BB:  MOVLW  47
00BC:  MOVWF  04
00BD:  BCF    03.7
00BE:  MOVF   00,W
00BF:  BTFSC  03.2
00C0:  GOTO   0CF
00C1:  MOVLW  01
00C2:  MOVWF  78
00C3:  CLRF   77
00C4:  DECFSZ 77,F
00C5:  GOTO   0C4
00C6:  DECFSZ 78,F
00C7:  GOTO   0C3
00C8:  MOVLW  4A
00C9:  MOVWF  77
00CA:  DECFSZ 77,F
00CB:  GOTO   0CA
00CC:  GOTO   0CD
00CD:  DECFSZ 00,F
00CE:  GOTO   0C1
00CF:  RETURN
*
037F:  MOVLW  12
0380:  SUBWF  47,F
0381:  BTFSS  03.0
0382:  GOTO   392
0383:  MOVLW  47
0384:  MOVWF  04
0385:  BCF    03.7
0386:  MOVLW  FC
0387:  ANDWF  00,F
0388:  BCF    03.0
0389:  RRF    00,F
038A:  RRF    00,F
038B:  MOVF   00,W
038C:  BTFSC  03.2
038D:  GOTO   392
038E:  GOTO   390
038F:  NOP
0390:  DECFSZ 00,F
0391:  GOTO   38F
....................  
.................... #include <lcd2.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_xy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... #define LCD_RS_PIN      PIN_E1                                    //// 
.................... #define LCD_RW_PIN      PIN_E2                                    //// 
.................... #define LCD_DATA4       PIN_D4                                    //// 
.................... #define LCD_DATA5       PIN_D5                                    //// 
.................... #define LCD_DATA6       PIN_D6                                    //// 
.................... #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0134:  BSF    08.4
....................    output_float(LCD_DATA5); 
0135:  BSF    08.5
....................    output_float(LCD_DATA6); 
0136:  BSF    08.6
....................    output_float(LCD_DATA7); 
0137:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0138:  BCF    03.5
0139:  BSF    09.2
013A:  BSF    03.5
013B:  BCF    09.2
....................    delay_cycles(1); 
013C:  NOP
....................    lcd_output_enable(1); 
013D:  BCF    03.5
013E:  BSF    09.0
013F:  BSF    03.5
0140:  BCF    09.0
....................    delay_cycles(1); 
0141:  NOP
....................    high = lcd_read_nibble(); 
0142:  BCF    03.5
0143:  CALL   0FB
0144:  MOVF   78,W
0145:  MOVWF  42
....................        
....................    lcd_output_enable(0); 
0146:  BCF    09.0
0147:  BSF    03.5
0148:  BCF    09.0
....................    delay_cycles(1); 
0149:  NOP
....................    lcd_output_enable(1); 
014A:  BCF    03.5
014B:  BSF    09.0
014C:  BSF    03.5
014D:  BCF    09.0
....................    delay_us(1); 
014E:  NOP
....................    low = lcd_read_nibble(); 
014F:  BCF    03.5
0150:  CALL   0FB
0151:  MOVF   78,W
0152:  MOVWF  41
....................        
....................    lcd_output_enable(0); 
0153:  BCF    09.0
0154:  BSF    03.5
0155:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0156:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0157:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0158:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0159:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
015A:  BCF    03.5
015B:  SWAPF  42,W
015C:  MOVWF  77
015D:  MOVLW  F0
015E:  ANDWF  77,F
015F:  MOVF   77,W
0160:  IORWF  41,W
0161:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00FB:  CLRF   43
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00FC:  BSF    03.5
00FD:  BSF    08.4
00FE:  MOVLW  00
00FF:  BCF    03.5
0100:  BTFSC  08.4
0101:  MOVLW  01
0102:  IORWF  43,F
....................    n |= input(LCD_DATA5) << 1; 
0103:  BSF    03.5
0104:  BSF    08.5
0105:  MOVLW  00
0106:  BCF    03.5
0107:  BTFSC  08.5
0108:  MOVLW  01
0109:  MOVWF  77
010A:  BCF    03.0
010B:  RLF    77,F
010C:  MOVF   77,W
010D:  IORWF  43,F
....................    n |= input(LCD_DATA6) << 2; 
010E:  BSF    03.5
010F:  BSF    08.6
0110:  MOVLW  00
0111:  BCF    03.5
0112:  BTFSC  08.6
0113:  MOVLW  01
0114:  MOVWF  77
0115:  RLF    77,F
0116:  RLF    77,F
0117:  MOVLW  FC
0118:  ANDWF  77,F
0119:  MOVF   77,W
011A:  IORWF  43,F
....................    n |= input(LCD_DATA7) << 3; 
011B:  BSF    03.5
011C:  BSF    08.7
011D:  MOVLW  00
011E:  BCF    03.5
011F:  BTFSC  08.7
0120:  MOVLW  01
0121:  MOVWF  77
0122:  RLF    77,F
0123:  RLF    77,F
0124:  RLF    77,F
0125:  MOVLW  F8
0126:  ANDWF  77,F
0127:  MOVF   77,W
0128:  IORWF  43,F
....................     
....................    return(n); 
0129:  MOVF   43,W
012A:  MOVWF  78
....................   #else 
012B:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00D0:  BTFSC  42.0
00D1:  GOTO   0D4
00D2:  BCF    08.4
00D3:  GOTO   0D5
00D4:  BSF    08.4
00D5:  BSF    03.5
00D6:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00D7:  BCF    03.5
00D8:  BTFSC  42.1
00D9:  GOTO   0DC
00DA:  BCF    08.5
00DB:  GOTO   0DD
00DC:  BSF    08.5
00DD:  BSF    03.5
00DE:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00DF:  BCF    03.5
00E0:  BTFSC  42.2
00E1:  GOTO   0E4
00E2:  BCF    08.6
00E3:  GOTO   0E5
00E4:  BSF    08.6
00E5:  BSF    03.5
00E6:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00E7:  BCF    03.5
00E8:  BTFSC  42.3
00E9:  GOTO   0EC
00EA:  BCF    08.7
00EB:  GOTO   0ED
00EC:  BSF    08.7
00ED:  BSF    03.5
00EE:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00EF:  NOP
....................    lcd_output_enable(1); 
00F0:  BCF    03.5
00F1:  BSF    09.0
00F2:  BSF    03.5
00F3:  BCF    09.0
....................    delay_us(2); 
00F4:  GOTO   0F5
....................    lcd_output_enable(0); 
00F5:  BCF    03.5
00F6:  BCF    09.0
00F7:  BSF    03.5
00F8:  BCF    09.0
00F9:  BCF    03.5
00FA:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
012C:  BSF    03.5
012D:  BCF    09.0
....................    lcd_rs_tris(); 
012E:  BCF    09.1
....................    lcd_rw_tris(); 
012F:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0130:  BCF    03.5
0131:  BCF    09.1
0132:  BSF    03.5
0133:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0162:  MOVF   78,W
0163:  MOVWF  41
0164:  BTFSS  41.7
0165:  GOTO   168
0166:  BSF    03.5
0167:  GOTO   134
....................    lcd_output_rs(address); 
0168:  MOVF   3F,F
0169:  BTFSS  03.2
016A:  GOTO   16D
016B:  BCF    09.1
016C:  GOTO   16E
016D:  BSF    09.1
016E:  BSF    03.5
016F:  BCF    09.1
....................    delay_cycles(1); 
0170:  NOP
....................    lcd_output_rw(0); 
0171:  BCF    03.5
0172:  BCF    09.2
0173:  BSF    03.5
0174:  BCF    09.2
....................    delay_cycles(1); 
0175:  NOP
....................    lcd_output_enable(0); 
0176:  BCF    03.5
0177:  BCF    09.0
0178:  BSF    03.5
0179:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
017A:  BCF    03.5
017B:  SWAPF  40,W
017C:  MOVWF  41
017D:  MOVLW  0F
017E:  ANDWF  41,F
017F:  MOVF   41,W
0180:  MOVWF  42
0181:  CALL   0D0
....................    lcd_send_nibble(n & 0xf); 
0182:  MOVF   40,W
0183:  ANDLW  0F
0184:  MOVWF  41
0185:  MOVWF  42
0186:  CALL   0D0
0187:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0188:  MOVLW  28
0189:  MOVWF  30
018A:  MOVLW  0C
018B:  MOVWF  31
018C:  MOVLW  01
018D:  MOVWF  32
018E:  MOVLW  06
018F:  MOVWF  33
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0190:  BCF    09.0
0191:  BSF    03.5
0192:  BCF    09.0
....................    lcd_output_rs(0); 
0193:  BCF    03.5
0194:  BCF    09.1
0195:  BSF    03.5
0196:  BCF    09.1
....................    lcd_output_rw(0); 
0197:  BCF    03.5
0198:  BCF    09.2
0199:  BSF    03.5
019A:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
019B:  BCF    08.4
....................    output_drive(LCD_DATA5); 
019C:  BCF    08.5
....................    output_drive(LCD_DATA6); 
019D:  BCF    08.6
....................    output_drive(LCD_DATA7); 
019E:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
019F:  BCF    09.0
....................    lcd_rs_tris(); 
01A0:  BCF    09.1
....................    lcd_rw_tris(); 
01A1:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
01A2:  MOVLW  0F
01A3:  BCF    03.5
01A4:  MOVWF  47
01A5:  CALL   0BB
....................    for(i=1;i<=3;++i) 
01A6:  MOVLW  01
01A7:  MOVWF  2F
01A8:  MOVF   2F,W
01A9:  SUBLW  03
01AA:  BTFSS  03.0
01AB:  GOTO   1B4
....................    { 
....................        lcd_send_nibble(3); 
01AC:  MOVLW  03
01AD:  MOVWF  42
01AE:  CALL   0D0
....................        delay_ms(5); 
01AF:  MOVLW  05
01B0:  MOVWF  47
01B1:  CALL   0BB
01B2:  INCF   2F,F
01B3:  GOTO   1A8
....................    } 
....................     
....................    lcd_send_nibble(2); 
01B4:  MOVLW  02
01B5:  MOVWF  42
01B6:  CALL   0D0
....................    delay_ms(5); 
01B7:  MOVLW  05
01B8:  MOVWF  47
01B9:  CALL   0BB
....................    for(i=0;i<=3;++i) 
01BA:  CLRF   2F
01BB:  MOVF   2F,W
01BC:  SUBLW  03
01BD:  BTFSS  03.0
01BE:  GOTO   1CB
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01BF:  MOVLW  30
01C0:  ADDWF  2F,W
01C1:  MOVWF  04
01C2:  BCF    03.7
01C3:  MOVF   00,W
01C4:  MOVWF  34
01C5:  CLRF   3F
01C6:  MOVF   34,W
01C7:  MOVWF  40
01C8:  CALL   12C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01C9:  INCF   2F,F
01CA:  GOTO   1BB
01CB:  BSF    0A.3
01CC:  BCF    0A.4
01CD:  GOTO   02D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
01CE:  DECFSZ 3C,W
01CF:  GOTO   1D1
01D0:  GOTO   1D4
....................       address=LCD_LINE_TWO; 
01D1:  MOVLW  40
01D2:  MOVWF  3D
01D3:  GOTO   1D5
....................    else 
....................       address=0; 
01D4:  CLRF   3D
....................       
....................    address+=x-1; 
01D5:  MOVLW  01
01D6:  SUBWF  3B,W
01D7:  ADDWF  3D,F
....................    lcd_send_byte(0,0x80|address); 
01D8:  MOVF   3D,W
01D9:  IORLW  80
01DA:  MOVWF  3E
01DB:  CLRF   3F
01DC:  MOVF   3E,W
01DD:  MOVWF  40
01DE:  CALL   12C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01DF:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01E0:  MOVF   3A,W
01E1:  XORLW  07
01E2:  BTFSC  03.2
01E3:  GOTO   1EE
01E4:  XORLW  0B
01E5:  BTFSC  03.2
01E6:  GOTO   1F3
01E7:  XORLW  06
01E8:  BTFSC  03.2
01E9:  GOTO   1FB
01EA:  XORLW  02
01EB:  BTFSC  03.2
01EC:  GOTO   201
01ED:  GOTO   206
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01EE:  MOVLW  01
01EF:  MOVWF  3B
01F0:  MOVWF  3C
01F1:  CALL   1CE
01F2:  GOTO   20B
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01F3:  CLRF   3F
01F4:  MOVLW  01
01F5:  MOVWF  40
01F6:  CALL   12C
....................                      delay_ms(2); 
01F7:  MOVLW  02
01F8:  MOVWF  47
01F9:  CALL   0BB
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01FA:  GOTO   20B
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01FB:  MOVLW  01
01FC:  MOVWF  3B
01FD:  MOVLW  02
01FE:  MOVWF  3C
01FF:  CALL   1CE
0200:  GOTO   20B
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0201:  CLRF   3F
0202:  MOVLW  10
0203:  MOVWF  40
0204:  CALL   12C
0205:  GOTO   20B
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0206:  MOVLW  01
0207:  MOVWF  3F
0208:  MOVF   3A,W
0209:  MOVWF  40
020A:  CALL   12C
....................      #endif 
....................    } 
020B:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
*
0262:  RLF    3A,F
0263:  RLF    3A,F
0264:  RLF    3A,F
0265:  MOVLW  F8
0266:  ANDWF  3A,F
....................    which &= 0x38; 
0267:  MOVLW  38
0268:  ANDWF  3A,F
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
0269:  MOVF   3A,W
026A:  IORLW  40
026B:  MOVWF  3E
026C:  CLRF   3F
026D:  MOVF   3E,W
026E:  MOVWF  40
026F:  CALL   12C
....................  
....................    for(i=0; i<8; i++) 
0270:  CLRF   3D
0271:  MOVF   3D,W
0272:  SUBLW  07
0273:  BTFSS  03.0
0274:  GOTO   288
....................    { 
....................       lcd_send_byte(1, *ptr++); 
0275:  MOVF   3C,W
0276:  MOVWF  7A
0277:  MOVF   3B,W
0278:  INCF   3B,F
0279:  BTFSC  03.2
027A:  INCF   3C,F
027B:  MOVWF  04
027C:  BCF    03.7
027D:  BTFSC  7A.0
027E:  BSF    03.7
027F:  MOVF   00,W
0280:  MOVWF  3E
0281:  MOVLW  01
0282:  MOVWF  3F
0283:  MOVF   3E,W
0284:  MOVWF  40
0285:  CALL   12C
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
0286:  INCF   3D,F
0287:  GOTO   271
0288:  RETURN
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
080F:  BCF    03.5
0810:  CLRF   20
0811:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
05F0:  MOVF   25,W
05F1:  MOVWF  49
05F2:  MOVF   24,W
05F3:  MOVWF  48
05F4:  MOVF   23,W
05F5:  MOVWF  47
05F6:  MOVF   22,W
05F7:  MOVWF  46
05F8:  MOVLW  41
05F9:  MOVWF  4D
05FA:  MOVLW  C6
05FB:  MOVWF  4C
05FC:  MOVLW  4E
05FD:  MOVWF  4B
05FE:  MOVLW  6D
05FF:  MOVWF  4A
0600:  CALL   339
0601:  MOVLW  39
0602:  ADDWF  77,W
0603:  MOVWF  22
0604:  MOVF   78,W
0605:  MOVWF  23
0606:  MOVLW  30
0607:  BTFSC  03.0
0608:  MOVLW  31
0609:  ADDWF  23,F
060A:  MOVF   79,W
060B:  MOVWF  24
060C:  MOVLW  00
060D:  BTFSC  03.0
060E:  MOVLW  01
060F:  ADDWF  24,F
0610:  MOVF   7A,W
0611:  MOVWF  25
0612:  MOVLW  00
0613:  BTFSC  03.0
0614:  MOVLW  01
0615:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0616:  MOVF   24,W
0617:  MOVWF  77
0618:  MOVF   25,W
0619:  MOVWF  78
061A:  CLRF   79
061B:  CLRF   7A
061C:  MOVF   25,W
061D:  MOVWF  31
061E:  MOVF   24,W
061F:  MOVWF  30
0620:  MOVF   25,W
0621:  MOVWF  43
0622:  MOVF   24,W
0623:  MOVWF  42
0624:  MOVLW  7F
0625:  MOVWF  45
0626:  MOVLW  FF
0627:  MOVWF  44
0628:  CALL   314
0629:  MOVF   77,W
062A:  MOVWF  78
062B:  MOVF   7A,W
062C:  MOVWF  79
062D:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <buzzer_tone.c> 
.................... /* #include <buzzer_tone.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 22/05/2020 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... void do_delay(int ms_delay, int num_ms, int us_delay, int num_us) 
.................... { 
....................    int i; 
....................  
....................  for(i=0;i<num_ms;i++) 
*
0363:  CLRF   46
0364:  MOVF   43,W
0365:  SUBWF  46,W
0366:  BTFSC  03.0
0367:  GOTO   36D
....................   delay_ms(250); 
0368:  MOVLW  FA
0369:  MOVWF  47
036A:  CALL   0BB
036B:  INCF   46,F
036C:  GOTO   364
....................  delay_ms(ms_delay); 
036D:  MOVF   42,W
036E:  MOVWF  47
036F:  CALL   0BB
....................  for(i=0;i<num_us;i++) 
0370:  CLRF   46
0371:  MOVF   45,W
0372:  SUBWF  46,W
0373:  BTFSC  03.0
0374:  GOTO   37D
....................   delay_us(250); 
0375:  MOVLW  52
0376:  MOVWF  77
0377:  DECFSZ 77,F
0378:  GOTO   377
0379:  GOTO   37A
037A:  NOP
037B:  INCF   46,F
037C:  GOTO   371
....................  delay_us(us_delay); 
037D:  MOVF   44,W
037E:  MOVWF  47
*
0392:  RETURN
.................... } 
....................  
.................... void generate_tone(int8 pin_tone, long frequency, long duration) 
.................... { 
....................    int32 total_delay_time; 
....................    long total_ms_delay_time, total_us_delay_time; 
....................    int num_us_delays, num_ms_delays, ms_delay_time, us_delay_time; 
....................    long num_periods; 
....................  
....................    total_delay_time = (1000000/frequency)/2-10; 
*
03B3:  BCF    03.1
03B4:  CLRF   4D
03B5:  MOVLW  0F
03B6:  MOVWF  4C
03B7:  MOVLW  42
03B8:  MOVWF  4B
03B9:  MOVLW  40
03BA:  MOVWF  4A
03BB:  CLRF   51
03BC:  CLRF   50
03BD:  MOVF   31,W
03BE:  MOVWF  4F
03BF:  MOVF   30,W
03C0:  MOVWF  4E
03C1:  CALL   2C5
03C2:  MOVF   7A,W
03C3:  MOVWF  45
03C4:  MOVF   79,W
03C5:  MOVWF  44
03C6:  MOVF   78,W
03C7:  MOVWF  43
03C8:  MOVF   77,W
03C9:  MOVWF  42
03CA:  BCF    03.0
03CB:  RRF    45,F
03CC:  RRF    44,F
03CD:  RRF    43,F
03CE:  RRF    42,F
03CF:  MOVLW  0A
03D0:  SUBWF  42,W
03D1:  MOVWF  34
03D2:  MOVF   43,W
03D3:  MOVWF  35
03D4:  MOVLW  00
03D5:  BTFSS  03.0
03D6:  MOVLW  01
03D7:  SUBWF  35,F
03D8:  MOVF   44,W
03D9:  MOVWF  36
03DA:  MOVLW  00
03DB:  BTFSS  03.0
03DC:  MOVLW  01
03DD:  SUBWF  36,F
03DE:  MOVF   45,W
03DF:  MOVWF  37
03E0:  MOVLW  00
03E1:  BTFSS  03.0
03E2:  MOVLW  01
03E3:  SUBWF  37,F
....................  
....................    total_ms_delay_time = total_delay_time/1000; 
03E4:  BCF    03.1
03E5:  MOVF   37,W
03E6:  MOVWF  4D
03E7:  MOVF   36,W
03E8:  MOVWF  4C
03E9:  MOVF   35,W
03EA:  MOVWF  4B
03EB:  MOVF   34,W
03EC:  MOVWF  4A
03ED:  CLRF   51
03EE:  CLRF   50
03EF:  MOVLW  03
03F0:  MOVWF  4F
03F1:  MOVLW  E8
03F2:  MOVWF  4E
03F3:  CALL   2C5
03F4:  MOVF   78,W
03F5:  MOVWF  39
03F6:  MOVF   77,W
03F7:  MOVWF  38
....................    num_ms_delays = total_ms_delay_time/250; 
03F8:  MOVF   39,W
03F9:  MOVWF  43
03FA:  MOVF   38,W
03FB:  MOVWF  42
03FC:  CLRF   45
03FD:  MOVLW  FA
03FE:  MOVWF  44
03FF:  CALL   314
0400:  MOVF   78,W
0401:  MOVWF  3D
....................    ms_delay_time = total_ms_delay_time%250; 
0402:  MOVF   39,W
0403:  MOVWF  43
0404:  MOVF   38,W
0405:  MOVWF  42
0406:  CLRF   45
0407:  MOVLW  FA
0408:  MOVWF  44
0409:  CALL   314
040A:  MOVF   77,W
040B:  MOVWF  3E
....................  
....................    total_us_delay_time = total_delay_time%1000; 
040C:  BSF    03.1
040D:  MOVLW  42
040E:  MOVWF  04
040F:  BCF    03.7
0410:  MOVF   37,W
0411:  MOVWF  4D
0412:  MOVF   36,W
0413:  MOVWF  4C
0414:  MOVF   35,W
0415:  MOVWF  4B
0416:  MOVF   34,W
0417:  MOVWF  4A
0418:  CLRF   51
0419:  CLRF   50
041A:  MOVLW  03
041B:  MOVWF  4F
041C:  MOVLW  E8
041D:  MOVWF  4E
041E:  CALL   2C5
041F:  MOVF   43,W
0420:  MOVWF  3B
0421:  MOVF   42,W
0422:  MOVWF  3A
....................    num_us_delays = total_us_delay_time/250; 
0423:  MOVF   3B,W
0424:  MOVWF  43
0425:  MOVF   3A,W
0426:  MOVWF  42
0427:  CLRF   45
0428:  MOVLW  FA
0429:  MOVWF  44
042A:  CALL   314
042B:  MOVF   78,W
042C:  MOVWF  3C
....................    us_delay_time = total_us_delay_time%250; 
042D:  MOVF   3B,W
042E:  MOVWF  43
042F:  MOVF   3A,W
0430:  MOVWF  42
0431:  CLRF   45
0432:  MOVLW  FA
0433:  MOVWF  44
0434:  CALL   314
0435:  MOVF   77,W
0436:  MOVWF  3F
....................  
....................    num_periods = ((int32)duration*1000)/(1000000/frequency); 
0437:  CLRF   45
0438:  CLRF   44
0439:  MOVF   33,W
043A:  MOVWF  43
043B:  MOVF   32,W
043C:  MOVWF  42
043D:  MOVF   45,W
043E:  MOVWF  49
043F:  MOVF   44,W
0440:  MOVWF  48
0441:  MOVF   33,W
0442:  MOVWF  47
0443:  MOVF   32,W
0444:  MOVWF  46
0445:  CLRF   4D
0446:  CLRF   4C
0447:  MOVLW  03
0448:  MOVWF  4B
0449:  MOVLW  E8
044A:  MOVWF  4A
044B:  CALL   339
044C:  MOVF   7A,W
044D:  MOVWF  45
044E:  MOVF   79,W
044F:  MOVWF  44
0450:  MOVF   78,W
0451:  MOVWF  43
0452:  MOVF   77,W
0453:  MOVWF  42
0454:  BCF    03.1
0455:  CLRF   4D
0456:  MOVLW  0F
0457:  MOVWF  4C
0458:  MOVLW  42
0459:  MOVWF  4B
045A:  MOVLW  40
045B:  MOVWF  4A
045C:  CLRF   51
045D:  CLRF   50
045E:  MOVF   31,W
045F:  MOVWF  4F
0460:  MOVF   30,W
0461:  MOVWF  4E
0462:  CALL   2C5
0463:  MOVF   7A,W
0464:  MOVWF  49
0465:  MOVF   79,W
0466:  MOVWF  48
0467:  MOVF   78,W
0468:  MOVWF  47
0469:  MOVF   77,W
046A:  MOVWF  46
046B:  BCF    03.1
046C:  MOVF   45,W
046D:  MOVWF  4D
046E:  MOVF   44,W
046F:  MOVWF  4C
0470:  MOVF   43,W
0471:  MOVWF  4B
0472:  MOVF   42,W
0473:  MOVWF  4A
0474:  MOVF   7A,W
0475:  MOVWF  51
0476:  MOVF   79,W
0477:  MOVWF  50
0478:  MOVF   78,W
0479:  MOVWF  4F
047A:  MOVF   77,W
047B:  MOVWF  4E
047C:  CALL   2C5
047D:  MOVF   78,W
047E:  MOVWF  41
047F:  MOVF   77,W
0480:  MOVWF  40
....................  
....................    while((num_periods--) != 0) 
0481:  MOVF   41,W
0482:  MOVWF  7A
0483:  MOVF   40,W
0484:  BTFSC  03.2
0485:  DECF   41,F
0486:  DECF   40,F
0487:  MOVWF  42
0488:  MOVF   7A,W
0489:  MOVWF  43
048A:  MOVF   42,F
048B:  BTFSS  03.2
048C:  GOTO   490
048D:  MOVF   43,F
048E:  BTFSC  03.2
048F:  GOTO   4BE
....................    { 
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
0490:  MOVF   3E,W
0491:  MOVWF  42
0492:  MOVF   3D,W
0493:  MOVWF  43
0494:  MOVF   3F,W
0495:  MOVWF  44
0496:  MOVF   3C,W
0497:  MOVWF  45
0498:  CALL   363
....................       output_high(pin_tone); 
0499:  MOVF   2F,W
049A:  MOVWF  42
049B:  MOVLW  01
049C:  MOVWF  43
049D:  CLRF   45
049E:  CLRF   44
049F:  CALL   393
04A0:  MOVF   2F,W
04A1:  MOVWF  42
04A2:  CLRF   43
04A3:  CLRF   45
04A4:  MOVLW  80
04A5:  MOVWF  44
04A6:  CALL   393
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
04A7:  MOVF   3E,W
04A8:  MOVWF  42
04A9:  MOVF   3D,W
04AA:  MOVWF  43
04AB:  MOVF   3F,W
04AC:  MOVWF  44
04AD:  MOVF   3C,W
04AE:  MOVWF  45
04AF:  CALL   363
....................       output_low(pin_tone); 
04B0:  MOVF   2F,W
04B1:  MOVWF  42
04B2:  CLRF   43
04B3:  CLRF   45
04B4:  CLRF   44
04B5:  CALL   393
04B6:  MOVF   2F,W
04B7:  MOVWF  42
04B8:  CLRF   43
04B9:  CLRF   45
04BA:  MOVLW  80
04BB:  MOVWF  44
04BC:  CALL   393
04BD:  GOTO   481
....................    } 
....................    return; 
04BE:  RETURN
.................... } 
....................  
....................  
.................... #define button PIN_B0 
.................... #define buzzer PIN_B1 
.................... #define vida1 PIN_B2 
.................... #define vida2 PIN_B3 
.................... #define vida3 PIN_B4 
....................  
.................... int16 ctf = 1000; 
....................  
.................... int8 random; 
.................... int1 dp; 
.................... int8 st; 
.................... int1 pas; 
.................... int cuen; 
.................... unsigned int16 sr; 
....................  
.................... lcd_init(); 
....................  
.................... //---------SE GENERAN LAS FIGURAS CON CGRAM--------- 
....................  
.................... // dinosaurio sin pata izquierda 
.................... void dino1(int8 x, int8 y) 
.................... { 
....................    int dinosaurio1[8] = {7, 23, 22, 31, 14, 2, 3, 0}; // creamos el c gram 
*
0289:  MOVLW  07
028A:  MOVWF  32
028B:  MOVLW  17
028C:  MOVWF  33
028D:  MOVLW  16
028E:  MOVWF  34
028F:  MOVLW  1F
0290:  MOVWF  35
0291:  MOVLW  0E
0292:  MOVWF  36
0293:  MOVLW  02
0294:  MOVWF  37
0295:  MOVLW  03
0296:  MOVWF  38
0297:  CLRF   39
....................    lcd_set_cgram_char(1, dinosaurio1);                // guardamos el c gram 
0298:  MOVLW  01
0299:  MOVWF  3A
029A:  CLRF   3C
029B:  MOVLW  32
029C:  MOVWF  3B
029D:  CALL   262
....................    lcd_gotoxy(x, y);                                  // ubicamos cursor 
029E:  MOVF   30,W
029F:  MOVWF  3B
02A0:  MOVF   31,W
02A1:  MOVWF  3C
02A2:  CALL   1CE
....................    lcd_putc(1);                                       // dibujamos segundo dinosaurio1 
02A3:  MOVLW  01
02A4:  MOVWF  3A
02A5:  CALL   1E0
02A6:  RETURN
.................... } 
....................  
.................... // dinosaurio sin pata derecha 
.................... void dino2(int8 x, int8 y) 
.................... { 
....................    int dinosaurio2[8] = {7, 23, 22, 31, 14, 8, 12, 0}; // creamos el c gram 
02A7:  MOVLW  07
02A8:  MOVWF  32
02A9:  MOVLW  17
02AA:  MOVWF  33
02AB:  MOVLW  16
02AC:  MOVWF  34
02AD:  MOVLW  1F
02AE:  MOVWF  35
02AF:  MOVLW  0E
02B0:  MOVWF  36
02B1:  MOVLW  08
02B2:  MOVWF  37
02B3:  MOVLW  0C
02B4:  MOVWF  38
02B5:  CLRF   39
....................    lcd_set_cgram_char(2, dinosaurio2);                 // guardamos el c gram 
02B6:  MOVLW  02
02B7:  MOVWF  3A
02B8:  CLRF   3C
02B9:  MOVLW  32
02BA:  MOVWF  3B
02BB:  CALL   262
....................    lcd_gotoxy(x, y);                                   // ubicamos cursor 
02BC:  MOVF   30,W
02BD:  MOVWF  3B
02BE:  MOVF   31,W
02BF:  MOVWF  3C
02C0:  CALL   1CE
....................    lcd_putc(2);                                        // dibujamos 
02C1:  MOVLW  02
02C2:  MOVWF  3A
02C3:  CALL   1E0
02C4:  RETURN
.................... } 
....................  
.................... // cactus grande 
.................... void cact1(int8 x, int8 y) 
.................... { 
....................    int cactus1[8] = {6, 22, 22, 30, 30, 6, 6, 31}; // creamos el c gram 
*
057B:  MOVLW  06
057C:  MOVWF  32
057D:  MOVLW  16
057E:  MOVWF  33
057F:  MOVWF  34
0580:  MOVLW  1E
0581:  MOVWF  35
0582:  MOVWF  36
0583:  MOVLW  06
0584:  MOVWF  37
0585:  MOVWF  38
0586:  MOVLW  1F
0587:  MOVWF  39
....................    lcd_set_cgram_char(3, cactus1);                 // guardamos el c gram 
0588:  MOVLW  03
0589:  MOVWF  3A
058A:  CLRF   3C
058B:  MOVLW  32
058C:  MOVWF  3B
058D:  CALL   262
....................    lcd_gotoxy(x, y);                               // ubicamos cursor 
058E:  MOVF   30,W
058F:  MOVWF  3B
0590:  MOVF   31,W
0591:  MOVWF  3C
0592:  CALL   1CE
....................    lcd_putc(3);                                    // dibujamos 
0593:  MOVLW  03
0594:  MOVWF  3A
0595:  CALL   1E0
0596:  RETURN
.................... } 
....................  
.................... // cactus chico 
.................... void cact2(int8 x, int8 y) 
.................... { 
....................    int cactus2[8] = {0, 0, 12, 13, 15, 12, 12, 31}; 
*
062E:  CLRF   32
062F:  CLRF   33
0630:  MOVLW  0C
0631:  MOVWF  34
0632:  MOVLW  0D
0633:  MOVWF  35
0634:  MOVLW  0F
0635:  MOVWF  36
0636:  MOVLW  0C
0637:  MOVWF  37
0638:  MOVWF  38
0639:  MOVLW  1F
063A:  MOVWF  39
....................    lcd_set_cgram_char(4, cactus2); // guardamos el c gram 
063B:  MOVLW  04
063C:  MOVWF  3A
063D:  CLRF   3C
063E:  MOVLW  32
063F:  MOVWF  3B
0640:  CALL   262
....................    lcd_gotoxy(x, y);               // ubicamos cursor 
0641:  MOVF   30,W
0642:  MOVWF  3B
0643:  MOVF   31,W
0644:  MOVWF  3C
0645:  CALL   1CE
....................    lcd_putc(4);                    // dibujamos 
0646:  MOVLW  04
0647:  MOVWF  3A
0648:  CALL   1E0
0649:  RETURN
.................... } 
....................  
.................... // sol 1 
.................... void sole1(int8 x, int8 y) 
.................... { 
....................    int sol1[8] = {29, 28, 25, 2, 20, 0, 0, 0}; 
*
053F:  MOVLW  1D
0540:  MOVWF  31
0541:  MOVLW  1C
0542:  MOVWF  32
0543:  MOVLW  19
0544:  MOVWF  33
0545:  MOVLW  02
0546:  MOVWF  34
0547:  MOVLW  14
0548:  MOVWF  35
0549:  CLRF   36
054A:  CLRF   37
054B:  CLRF   38
....................    lcd_set_cgram_char(5, sol1); // guardamos el c gram 
054C:  MOVLW  05
054D:  MOVWF  3A
054E:  CLRF   3C
054F:  MOVLW  31
0550:  MOVWF  3B
0551:  CALL   262
....................    lcd_gotoxy(x, y);            // ubicamos cursor 
0552:  MOVF   2F,W
0553:  MOVWF  3B
0554:  MOVF   30,W
0555:  MOVWF  3C
0556:  CALL   1CE
....................    lcd_putc(5);                 // dibujamos 
0557:  MOVLW  05
0558:  MOVWF  3A
0559:  CALL   1E0
055A:  BSF    0A.3
055B:  BCF    0A.4
055C:  GOTO   311 (RETURN)
.................... } 
....................  
.................... // sol 2 
.................... void sole2(int8 x, int8 y) 
.................... { 
....................    int sol2[8] = {28, 29, 24, 2, 8, 0, 0, 0}; 
055D:  MOVLW  1C
055E:  MOVWF  31
055F:  MOVLW  1D
0560:  MOVWF  32
0561:  MOVLW  18
0562:  MOVWF  33
0563:  MOVLW  02
0564:  MOVWF  34
0565:  MOVLW  08
0566:  MOVWF  35
0567:  CLRF   36
0568:  CLRF   37
0569:  CLRF   38
....................    lcd_set_cgram_char(6, sol2); // guardamos el c gram 
056A:  MOVLW  06
056B:  MOVWF  3A
056C:  CLRF   3C
056D:  MOVLW  31
056E:  MOVWF  3B
056F:  CALL   262
....................    lcd_gotoxy(x, y);            // ubicamos cursor 
0570:  MOVF   2F,W
0571:  MOVWF  3B
0572:  MOVF   30,W
0573:  MOVWF  3C
0574:  CALL   1CE
....................    lcd_putc(6);                 // dibujamos 
0575:  MOVLW  06
0576:  MOVWF  3A
0577:  CALL   1E0
0578:  BSF    0A.3
0579:  BCF    0A.4
057A:  GOTO   324 (RETURN)
.................... } 
....................  
.................... void vel_juego() 
.................... { 
....................    //----------------------------------------------velocidad del juego----------------------------------------------------------------------- 
....................    if (sr <= 10) 
*
0597:  MOVF   2D,F
0598:  BTFSS  03.2
0599:  GOTO   5A1
059A:  MOVF   2C,W
059B:  SUBLW  0A
059C:  BTFSS  03.0
059D:  GOTO   5A1
....................    {                 // velocidad del ciclo 
....................       delay_ms(200); ////va aumentabndo la velocidad mientas aunmemnta la puntuacion "pun" 
059E:  MOVLW  C8
059F:  MOVWF  47
05A0:  CALL   0BB
....................    } 
....................    if (sr > 10 && sr < 20) 
05A1:  MOVF   2D,F
05A2:  BTFSS  03.2
05A3:  GOTO   5A8
05A4:  MOVF   2C,W
05A5:  SUBLW  0A
05A6:  BTFSC  03.0
05A7:  GOTO   5B2
05A8:  MOVF   2D,F
05A9:  BTFSS  03.2
05AA:  GOTO   5B2
05AB:  MOVF   2C,W
05AC:  SUBLW  13
05AD:  BTFSS  03.0
05AE:  GOTO   5B2
....................    { 
....................       delay_ms(150); 
05AF:  MOVLW  96
05B0:  MOVWF  47
05B1:  CALL   0BB
....................    } 
....................    if (sr >= 20 && sr < 30) 
05B2:  MOVF   2D,F
05B3:  BTFSS  03.2
05B4:  GOTO   5B9
05B5:  MOVF   2C,W
05B6:  SUBLW  13
05B7:  BTFSC  03.0
05B8:  GOTO   5C3
05B9:  MOVF   2D,F
05BA:  BTFSS  03.2
05BB:  GOTO   5C3
05BC:  MOVF   2C,W
05BD:  SUBLW  1D
05BE:  BTFSS  03.0
05BF:  GOTO   5C3
....................    { 
....................       delay_ms(80); 
05C0:  MOVLW  50
05C1:  MOVWF  47
05C2:  CALL   0BB
....................    } 
....................    if (sr >= 30 && sr < 50) 
05C3:  MOVF   2D,F
05C4:  BTFSS  03.2
05C5:  GOTO   5CA
05C6:  MOVF   2C,W
05C7:  SUBLW  1D
05C8:  BTFSC  03.0
05C9:  GOTO   5D4
05CA:  MOVF   2D,F
05CB:  BTFSS  03.2
05CC:  GOTO   5D4
05CD:  MOVF   2C,W
05CE:  SUBLW  31
05CF:  BTFSS  03.0
05D0:  GOTO   5D4
....................    { 
....................       delay_ms(70); 
05D1:  MOVLW  46
05D2:  MOVWF  47
05D3:  CALL   0BB
....................    } 
....................    if (sr >= 50 && sr < 100) 
05D4:  MOVF   2D,F
05D5:  BTFSS  03.2
05D6:  GOTO   5DB
05D7:  MOVF   2C,W
05D8:  SUBLW  31
05D9:  BTFSC  03.0
05DA:  GOTO   5E5
05DB:  MOVF   2D,F
05DC:  BTFSS  03.2
05DD:  GOTO   5E5
05DE:  MOVF   2C,W
05DF:  SUBLW  63
05E0:  BTFSS  03.0
05E1:  GOTO   5E5
....................    { 
....................       delay_ms(60); 
05E2:  MOVLW  3C
05E3:  MOVWF  47
05E4:  CALL   0BB
....................    } 
....................    if (sr < 100) 
05E5:  MOVF   2D,F
05E6:  BTFSS  03.2
05E7:  GOTO   5EF
05E8:  MOVF   2C,W
05E9:  SUBLW  63
05EA:  BTFSS  03.0
05EB:  GOTO   5EF
....................    { 
....................       delay_ms(50); 
05EC:  MOVLW  32
05ED:  MOVWF  47
05EE:  CALL   0BB
....................    } 
05EF:  RETURN
.................... } 
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  03
0804:  MOVWF  27
0805:  MOVLW  E8
0806:  MOVWF  26
0807:  BSF    03.5
0808:  BSF    1F.0
0809:  BSF    1F.1
080A:  BSF    1F.2
080B:  BCF    1F.3
080C:  MOVLW  07
080D:  MOVWF  1C
080E:  BCF    03.7
.................... { 
....................  
....................    DISABLE_INTERRUPTS(GLOBAL); 
*
0812:  BCF    0B.6
0813:  BCF    0B.7
0814:  BTFSC  0B.7
0815:  GOTO   013
....................    OUTPUT_LOW(vida1); 
0816:  BSF    03.5
0817:  BCF    06.2
0818:  BCF    03.5
0819:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
081A:  BSF    03.5
081B:  BCF    06.3
081C:  BCF    03.5
081D:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
081E:  BSF    03.5
081F:  BCF    06.4
0820:  BCF    03.5
0821:  BCF    06.4
....................    delay_ms(333); 
0822:  MOVLW  03
0823:  MOVWF  2F
0824:  MOVLW  6F
0825:  MOVWF  47
0826:  BCF    0A.3
0827:  CALL   0BB
0828:  BSF    0A.3
0829:  DECFSZ 2F,F
082A:  GOTO   024
....................    lcd_init(); 
082B:  BCF    0A.3
082C:  GOTO   188
082D:  BSF    0A.3
....................    // ENABLE_INTERRUPTS(INT_EXT); 
....................    // ENABLE_INTERRUPTS(GLOBAL); 
....................    lcd_gotoxy(1, 1); 
082E:  MOVLW  01
082F:  MOVWF  3B
0830:  MOVWF  3C
0831:  BCF    0A.3
0832:  CALL   1CE
0833:  BSF    0A.3
....................    printf(lcd_putc, " Mini Dino w.w !"); 
0834:  MOVLW  04
0835:  BSF    03.6
0836:  MOVWF  0D
0837:  MOVLW  00
0838:  MOVWF  0F
0839:  BCF    0A.3
083A:  BCF    03.6
083B:  CALL   20C
083C:  BSF    0A.3
....................    lcd_gotoxy(1, 2); 
083D:  MOVLW  01
083E:  MOVWF  3B
083F:  MOVLW  02
0840:  MOVWF  3C
0841:  BCF    0A.3
0842:  CALL   1CE
0843:  BSF    0A.3
....................    printf(lcd_putc, " PRESENTADO POR!"); 
0844:  MOVLW  0D
0845:  BSF    03.6
0846:  MOVWF  0D
0847:  MOVLW  00
0848:  MOVWF  0F
0849:  BCF    0A.3
084A:  BCF    03.6
084B:  CALL   20C
084C:  BSF    0A.3
....................    OUTPUT_HIGH(vida1); 
084D:  BSF    03.5
084E:  BCF    06.2
084F:  BCF    03.5
0850:  BSF    06.2
....................    OUTPUT_HIGH(vida2); 
0851:  BSF    03.5
0852:  BCF    06.3
0853:  BCF    03.5
0854:  BSF    06.3
....................    OUTPUT_HIGH(vida3); 
0855:  BSF    03.5
0856:  BCF    06.4
0857:  BCF    03.5
0858:  BSF    06.4
....................    delay_ms(1500); 
0859:  MOVLW  06
085A:  MOVWF  2F
085B:  MOVLW  FA
085C:  MOVWF  47
085D:  BCF    0A.3
085E:  CALL   0BB
085F:  BSF    0A.3
0860:  DECFSZ 2F,F
0861:  GOTO   05B
....................    OUTPUT_LOW(vida1); 
0862:  BSF    03.5
0863:  BCF    06.2
0864:  BCF    03.5
0865:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
0866:  BSF    03.5
0867:  BCF    06.3
0868:  BCF    03.5
0869:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
086A:  BSF    03.5
086B:  BCF    06.4
086C:  BCF    03.5
086D:  BCF    06.4
....................    delay_ms(1500); 
086E:  MOVLW  06
086F:  MOVWF  2F
0870:  MOVLW  FA
0871:  MOVWF  47
0872:  BCF    0A.3
0873:  CALL   0BB
0874:  BSF    0A.3
0875:  DECFSZ 2F,F
0876:  GOTO   070
....................  
....................    lcd_gotoxy(1, 1); 
0877:  MOVLW  01
0878:  MOVWF  3B
0879:  MOVWF  3C
087A:  BCF    0A.3
087B:  CALL   1CE
087C:  BSF    0A.3
....................    printf(lcd_putc, "JESUS A MONSALVE"); 
087D:  MOVLW  16
087E:  BSF    03.6
087F:  MOVWF  0D
0880:  MOVLW  00
0881:  MOVWF  0F
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   20C
0885:  BSF    0A.3
....................    lcd_gotoxy(1, 2); 
0886:  MOVLW  01
0887:  MOVWF  3B
0888:  MOVLW  02
0889:  MOVWF  3C
088A:  BCF    0A.3
088B:  CALL   1CE
088C:  BSF    0A.3
....................    printf(lcd_putc, "     ZERPA.     "); 
088D:  MOVLW  1F
088E:  BSF    03.6
088F:  MOVWF  0D
0890:  MOVLW  00
0891:  MOVWF  0F
0892:  BCF    0A.3
0893:  BCF    03.6
0894:  CALL   20C
0895:  BSF    0A.3
....................    OUTPUT_HIGH(vida1); 
0896:  BSF    03.5
0897:  BCF    06.2
0898:  BCF    03.5
0899:  BSF    06.2
....................    OUTPUT_HIGH(vida2); 
089A:  BSF    03.5
089B:  BCF    06.3
089C:  BCF    03.5
089D:  BSF    06.3
....................    OUTPUT_HIGH(vida3); 
089E:  BSF    03.5
089F:  BCF    06.4
08A0:  BCF    03.5
08A1:  BSF    06.4
....................    delay_ms(1500); 
08A2:  MOVLW  06
08A3:  MOVWF  2F
08A4:  MOVLW  FA
08A5:  MOVWF  47
08A6:  BCF    0A.3
08A7:  CALL   0BB
08A8:  BSF    0A.3
08A9:  DECFSZ 2F,F
08AA:  GOTO   0A4
....................    OUTPUT_LOW(vida1); 
08AB:  BSF    03.5
08AC:  BCF    06.2
08AD:  BCF    03.5
08AE:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
08AF:  BSF    03.5
08B0:  BCF    06.3
08B1:  BCF    03.5
08B2:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
08B3:  BSF    03.5
08B4:  BCF    06.4
08B5:  BCF    03.5
08B6:  BCF    06.4
....................    delay_ms(1500); 
08B7:  MOVLW  06
08B8:  MOVWF  2F
08B9:  MOVLW  FA
08BA:  MOVWF  47
08BB:  BCF    0A.3
08BC:  CALL   0BB
08BD:  BSF    0A.3
08BE:  DECFSZ 2F,F
08BF:  GOTO   0B9
....................  
....................    lcd_gotoxy(1, 1); 
08C0:  MOVLW  01
08C1:  MOVWF  3B
08C2:  MOVWF  3C
08C3:  BCF    0A.3
08C4:  CALL   1CE
08C5:  BSF    0A.3
....................    printf(lcd_putc, "   NO MATES AL  "); 
08C6:  MOVLW  28
08C7:  BSF    03.6
08C8:  MOVWF  0D
08C9:  MOVLW  00
08CA:  MOVWF  0F
08CB:  BCF    0A.3
08CC:  BCF    03.6
08CD:  CALL   20C
08CE:  BSF    0A.3
....................    lcd_gotoxy(1, 2); 
08CF:  MOVLW  01
08D0:  MOVWF  3B
08D1:  MOVLW  02
08D2:  MOVWF  3C
08D3:  BCF    0A.3
08D4:  CALL   1CE
08D5:  BSF    0A.3
....................    printf(lcd_putc, "   DINOSAURIO.  "); 
08D6:  MOVLW  31
08D7:  BSF    03.6
08D8:  MOVWF  0D
08D9:  MOVLW  00
08DA:  MOVWF  0F
08DB:  BCF    0A.3
08DC:  BCF    03.6
08DD:  CALL   20C
08DE:  BSF    0A.3
....................  
.................... menu: 
....................    /// saludamos con los leds 
....................    OUTPUT_HIGH(vida1); 
08DF:  BSF    03.5
08E0:  BCF    06.2
08E1:  BCF    03.5
08E2:  BSF    06.2
....................    OUTPUT_HIGH(vida2); 
08E3:  BSF    03.5
08E4:  BCF    06.3
08E5:  BCF    03.5
08E6:  BSF    06.3
....................    OUTPUT_HIGH(vida3); 
08E7:  BSF    03.5
08E8:  BCF    06.4
08E9:  BCF    03.5
08EA:  BSF    06.4
....................    delay_ms(ctf / 2); 
08EB:  BCF    03.0
08EC:  RRF    27,W
08ED:  MOVWF  30
08EE:  RRF    26,W
08EF:  MOVWF  2F
08F0:  MOVF   30,W
08F1:  MOVWF  31
08F2:  INCF   31,F
08F3:  DECF   31,F
08F4:  BTFSC  03.2
08F5:  GOTO   0FC
08F6:  MOVLW  FF
08F7:  MOVWF  47
08F8:  BCF    0A.3
08F9:  CALL   0BB
08FA:  BSF    0A.3
08FB:  GOTO   0F3
08FC:  MOVF   2F,W
08FD:  MOVWF  47
08FE:  BCF    0A.3
08FF:  CALL   0BB
0900:  BSF    0A.3
....................    OUTPUT_LOW(vida1); 
0901:  BSF    03.5
0902:  BCF    06.2
0903:  BCF    03.5
0904:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
0905:  BSF    03.5
0906:  BCF    06.3
0907:  BCF    03.5
0908:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
0909:  BSF    03.5
090A:  BCF    06.4
090B:  BCF    03.5
090C:  BCF    06.4
....................    delay_ms(ctf / 2); 
090D:  BCF    03.0
090E:  RRF    27,W
090F:  MOVWF  30
0910:  RRF    26,W
0911:  MOVWF  2F
0912:  MOVF   30,W
0913:  MOVWF  31
0914:  INCF   31,F
0915:  DECF   31,F
0916:  BTFSC  03.2
0917:  GOTO   11E
0918:  MOVLW  FF
0919:  MOVWF  47
091A:  BCF    0A.3
091B:  CALL   0BB
091C:  BSF    0A.3
091D:  GOTO   115
091E:  MOVF   2F,W
091F:  MOVWF  47
0920:  BCF    0A.3
0921:  CALL   0BB
0922:  BSF    0A.3
....................    OUTPUT_HIGH(vida1); 
0923:  BSF    03.5
0924:  BCF    06.2
0925:  BCF    03.5
0926:  BSF    06.2
....................    OUTPUT_HIGH(vida2); 
0927:  BSF    03.5
0928:  BCF    06.3
0929:  BCF    03.5
092A:  BSF    06.3
....................    OUTPUT_HIGH(vida3); 
092B:  BSF    03.5
092C:  BCF    06.4
092D:  BCF    03.5
092E:  BSF    06.4
....................    delay_ms(ctf / 2); 
092F:  BCF    03.0
0930:  RRF    27,W
0931:  MOVWF  30
0932:  RRF    26,W
0933:  MOVWF  2F
0934:  MOVF   30,W
0935:  MOVWF  31
0936:  INCF   31,F
0937:  DECF   31,F
0938:  BTFSC  03.2
0939:  GOTO   140
093A:  MOVLW  FF
093B:  MOVWF  47
093C:  BCF    0A.3
093D:  CALL   0BB
093E:  BSF    0A.3
093F:  GOTO   137
0940:  MOVF   2F,W
0941:  MOVWF  47
0942:  BCF    0A.3
0943:  CALL   0BB
0944:  BSF    0A.3
....................    OUTPUT_LOW(vida1); 
0945:  BSF    03.5
0946:  BCF    06.2
0947:  BCF    03.5
0948:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
0949:  BSF    03.5
094A:  BCF    06.3
094B:  BCF    03.5
094C:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
094D:  BSF    03.5
094E:  BCF    06.4
094F:  BCF    03.5
0950:  BCF    06.4
....................    delay_ms(ctf / 2); 
0951:  BCF    03.0
0952:  RRF    27,W
0953:  MOVWF  30
0954:  RRF    26,W
0955:  MOVWF  2F
0956:  MOVF   30,W
0957:  MOVWF  31
0958:  INCF   31,F
0959:  DECF   31,F
095A:  BTFSC  03.2
095B:  GOTO   162
095C:  MOVLW  FF
095D:  MOVWF  47
095E:  BCF    0A.3
095F:  CALL   0BB
0960:  BSF    0A.3
0961:  GOTO   159
0962:  MOVF   2F,W
0963:  MOVWF  47
0964:  BCF    0A.3
0965:  CALL   0BB
0966:  BSF    0A.3
....................    OUTPUT_HIGH(vida1); 
0967:  BSF    03.5
0968:  BCF    06.2
0969:  BCF    03.5
096A:  BSF    06.2
....................    OUTPUT_HIGH(vida2); 
096B:  BSF    03.5
096C:  BCF    06.3
096D:  BCF    03.5
096E:  BSF    06.3
....................    OUTPUT_HIGH(vida3); 
096F:  BSF    03.5
0970:  BCF    06.4
0971:  BCF    03.5
0972:  BSF    06.4
....................    delay_ms(ctf / 2); 
0973:  BCF    03.0
0974:  RRF    27,W
0975:  MOVWF  30
0976:  RRF    26,W
0977:  MOVWF  2F
0978:  MOVF   30,W
0979:  MOVWF  31
097A:  INCF   31,F
097B:  DECF   31,F
097C:  BTFSC  03.2
097D:  GOTO   184
097E:  MOVLW  FF
097F:  MOVWF  47
0980:  BCF    0A.3
0981:  CALL   0BB
0982:  BSF    0A.3
0983:  GOTO   17B
0984:  MOVF   2F,W
0985:  MOVWF  47
0986:  BCF    0A.3
0987:  CALL   0BB
0988:  BSF    0A.3
....................    OUTPUT_LOW(vida1); 
0989:  BSF    03.5
098A:  BCF    06.2
098B:  BCF    03.5
098C:  BCF    06.2
....................    OUTPUT_LOW(vida2); 
098D:  BSF    03.5
098E:  BCF    06.3
098F:  BCF    03.5
0990:  BCF    06.3
....................    OUTPUT_LOW(vida3); 
0991:  BSF    03.5
0992:  BCF    06.4
0993:  BCF    03.5
0994:  BCF    06.4
....................    while (input_state(button) == 0) 
0995:  BTFSC  06.0
0996:  GOTO   1E6
....................    { 
....................       dino1(1, 1);      // dibujamos segundo dinosaurio1 
0997:  MOVLW  01
0998:  MOVWF  30
0999:  MOVWF  31
099A:  BCF    0A.3
099B:  CALL   289
099C:  BSF    0A.3
....................       lcd_gotoxy(2, 1); // ubicamos cursor para texto 
099D:  MOVLW  02
099E:  MOVWF  3B
099F:  MOVLW  01
09A0:  MOVWF  3C
09A1:  BCF    0A.3
09A2:  CALL   1CE
09A3:  BSF    0A.3
....................       lcd_putc("DALE AL BOTON!!!"); 
09A4:  MOVLW  3A
09A5:  BSF    03.6
09A6:  MOVWF  0D
09A7:  MOVLW  00
09A8:  MOVWF  0F
09A9:  BCF    0A.3
09AA:  BCF    03.6
09AB:  CALL   20C
09AC:  BSF    0A.3
....................       lcd_gotoxy(1, 2); // ubicamos cursor para texto 
09AD:  MOVLW  01
09AE:  MOVWF  3B
09AF:  MOVLW  02
09B0:  MOVWF  3C
09B1:  BCF    0A.3
09B2:  CALL   1CE
09B3:  BSF    0A.3
....................       lcd_putc("                "); 
09B4:  MOVLW  43
09B5:  BSF    03.6
09B6:  MOVWF  0D
09B7:  MOVLW  00
09B8:  MOVWF  0F
09B9:  BCF    0A.3
09BA:  BCF    03.6
09BB:  CALL   20C
09BC:  BSF    0A.3
....................       delay_ms(500); 
09BD:  MOVLW  02
09BE:  MOVWF  2F
09BF:  MOVLW  FA
09C0:  MOVWF  47
09C1:  BCF    0A.3
09C2:  CALL   0BB
09C3:  BSF    0A.3
09C4:  DECFSZ 2F,F
09C5:  GOTO   1BF
....................       dino2(1, 1);      // dibujamos segundo dinosaurio2 
09C6:  MOVLW  01
09C7:  MOVWF  30
09C8:  MOVWF  31
09C9:  BCF    0A.3
09CA:  CALL   2A7
09CB:  BSF    0A.3
....................       lcd_gotoxy(1, 2); // ubicamos cursor 
09CC:  MOVLW  01
09CD:  MOVWF  3B
09CE:  MOVLW  02
09CF:  MOVWF  3C
09D0:  BCF    0A.3
09D1:  CALL   1CE
09D2:  BSF    0A.3
....................       lcd_putc("YO SE Q QUIERES!!"); 
09D3:  MOVLW  4C
09D4:  BSF    03.6
09D5:  MOVWF  0D
09D6:  MOVLW  00
09D7:  MOVWF  0F
09D8:  BCF    0A.3
09D9:  BCF    03.6
09DA:  CALL   20C
09DB:  BSF    0A.3
....................       delay_ms(500); 
09DC:  MOVLW  02
09DD:  MOVWF  2F
09DE:  MOVLW  FA
09DF:  MOVWF  47
09E0:  BCF    0A.3
09E1:  CALL   0BB
09E2:  BSF    0A.3
09E3:  DECFSZ 2F,F
09E4:  GOTO   1DE
09E5:  GOTO   195
....................    } 
....................  
....................    while (input_state(button) == 1) 
09E6:  BTFSS  06.0
09E7:  GOTO   240
....................    { 
....................  
....................       generate_tone(buzzer, 500, 64); 
09E8:  MOVLW  31
09E9:  MOVWF  2F
09EA:  MOVLW  01
09EB:  MOVWF  31
09EC:  MOVLW  F4
09ED:  MOVWF  30
09EE:  CLRF   33
09EF:  MOVLW  40
09F0:  MOVWF  32
09F1:  BCF    0A.3
09F2:  CALL   3B3
09F3:  BSF    0A.3
....................       delay_ms(CTF); 
09F4:  MOVF   27,W
09F5:  MOVWF  2F
09F6:  INCF   2F,F
09F7:  DECF   2F,F
09F8:  BTFSC  03.2
09F9:  GOTO   200
09FA:  MOVLW  FF
09FB:  MOVWF  47
09FC:  BCF    0A.3
09FD:  CALL   0BB
09FE:  BSF    0A.3
09FF:  GOTO   1F7
0A00:  MOVF   26,W
0A01:  MOVWF  47
0A02:  BCF    0A.3
0A03:  CALL   0BB
0A04:  BSF    0A.3
....................  
....................       generate_tone(buzzer, 500, 64); 
0A05:  MOVLW  31
0A06:  MOVWF  2F
0A07:  MOVLW  01
0A08:  MOVWF  31
0A09:  MOVLW  F4
0A0A:  MOVWF  30
0A0B:  CLRF   33
0A0C:  MOVLW  40
0A0D:  MOVWF  32
0A0E:  BCF    0A.3
0A0F:  CALL   3B3
0A10:  BSF    0A.3
....................       delay_ms(CTF); 
0A11:  MOVF   27,W
0A12:  MOVWF  2F
0A13:  INCF   2F,F
0A14:  DECF   2F,F
0A15:  BTFSC  03.2
0A16:  GOTO   21D
0A17:  MOVLW  FF
0A18:  MOVWF  47
0A19:  BCF    0A.3
0A1A:  CALL   0BB
0A1B:  BSF    0A.3
0A1C:  GOTO   214
0A1D:  MOVF   26,W
0A1E:  MOVWF  47
0A1F:  BCF    0A.3
0A20:  CALL   0BB
0A21:  BSF    0A.3
....................  
....................       generate_tone(buzzer, 1000, 80); 
0A22:  MOVLW  31
0A23:  MOVWF  2F
0A24:  MOVLW  03
0A25:  MOVWF  31
0A26:  MOVLW  E8
0A27:  MOVWF  30
0A28:  CLRF   33
0A29:  MOVLW  50
0A2A:  MOVWF  32
0A2B:  BCF    0A.3
0A2C:  CALL   3B3
0A2D:  BSF    0A.3
....................       delay_ms(CTF); 
0A2E:  MOVF   27,W
0A2F:  MOVWF  2F
0A30:  INCF   2F,F
0A31:  DECF   2F,F
0A32:  BTFSC  03.2
0A33:  GOTO   23A
0A34:  MOVLW  FF
0A35:  MOVWF  47
0A36:  BCF    0A.3
0A37:  CALL   0BB
0A38:  BSF    0A.3
0A39:  GOTO   231
0A3A:  MOVF   26,W
0A3B:  MOVWF  47
0A3C:  BCF    0A.3
0A3D:  CALL   0BB
0A3E:  BSF    0A.3
0A3F:  GOTO   1E6
....................  
....................       // RunDino(ctf/5); 
....................    } 
....................    lcd_putc("\f"); // borramos pantalla 
0A40:  MOVLW  55
0A41:  BSF    03.6
0A42:  MOVWF  0D
0A43:  MOVLW  00
0A44:  MOVWF  0F
0A45:  BCF    0A.3
0A46:  BCF    03.6
0A47:  CALL   20C
0A48:  BSF    0A.3
....................    lcd_putc("AYYY PAPAA!! XD"); 
0A49:  MOVLW  56
0A4A:  BSF    03.6
0A4B:  MOVWF  0D
0A4C:  MOVLW  00
0A4D:  MOVWF  0F
0A4E:  BCF    0A.3
0A4F:  BCF    03.6
0A50:  CALL   20C
0A51:  BSF    0A.3
....................    lcd_gotoxy(4, 2); // ubicamos cursor 
0A52:  MOVLW  04
0A53:  MOVWF  3B
0A54:  MOVLW  02
0A55:  MOVWF  3C
0A56:  BCF    0A.3
0A57:  CALL   1CE
0A58:  BSF    0A.3
....................    lcd_putc("ARRANCAMOS"); 
0A59:  MOVLW  5E
0A5A:  BSF    03.6
0A5B:  MOVWF  0D
0A5C:  MOVLW  00
0A5D:  MOVWF  0F
0A5E:  BCF    0A.3
0A5F:  BCF    03.6
0A60:  CALL   20C
0A61:  BSF    0A.3
....................    delay_ms(CTF);  // esperamos 
0A62:  MOVF   27,W
0A63:  MOVWF  2F
0A64:  INCF   2F,F
0A65:  DECF   2F,F
0A66:  BTFSC  03.2
0A67:  GOTO   26E
0A68:  MOVLW  FF
0A69:  MOVWF  47
0A6A:  BCF    0A.3
0A6B:  CALL   0BB
0A6C:  BSF    0A.3
0A6D:  GOTO   265
0A6E:  MOVF   26,W
0A6F:  MOVWF  47
0A70:  BCF    0A.3
0A71:  CALL   0BB
0A72:  BSF    0A.3
....................    lcd_putc("\f"); // borramos pantalla 
0A73:  MOVLW  64
0A74:  BSF    03.6
0A75:  MOVWF  0D
0A76:  MOVLW  00
0A77:  MOVWF  0F
0A78:  BCF    0A.3
0A79:  BCF    03.6
0A7A:  CALL   20C
0A7B:  BSF    0A.3
....................  
....................    cuen = 19; 
0A7C:  MOVLW  13
0A7D:  MOVWF  2B
....................    sr = 0; 
0A7E:  CLRF   2D
0A7F:  CLRF   2C
....................    int vida = 3; 
0A80:  MOVLW  03
0A81:  MOVWF  2E
....................  
....................    while (TRUE) 
....................    { // HACEMOS UN CICLO INFINITO 
....................  
....................       lcd_gotoxy(9, 1);           // ubicamos cursor 
0A82:  MOVLW  09
0A83:  MOVWF  3B
0A84:  MOVLW  01
0A85:  MOVWF  3C
0A86:  BCF    0A.3
0A87:  CALL   1CE
0A88:  BSF    0A.3
....................       lcd_putc("P=");             // dibujamos la puntuacion 
0A89:  MOVLW  65
0A8A:  BSF    03.6
0A8B:  MOVWF  0D
0A8C:  MOVLW  00
0A8D:  MOVWF  0F
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   20C
0A91:  BSF    0A.3
....................       lcd_gotoxy(11, 1);          // ubicamos cursor 
0A92:  MOVLW  0B
0A93:  MOVWF  3B
0A94:  MOVLW  01
0A95:  MOVWF  3C
0A96:  BCF    0A.3
0A97:  CALL   1CE
0A98:  BSF    0A.3
....................       printf(lcd_putc "%ld", sr); // iniciciamos puntuacion 
0A99:  MOVLW  10
0A9A:  MOVWF  04
0A9B:  MOVF   2D,W
0A9C:  MOVWF  30
0A9D:  MOVF   2C,W
0A9E:  MOVWF  2F
0A9F:  BCF    0A.3
0AA0:  CALL   4BF
0AA1:  BSF    0A.3
....................  
....................       if (vida == 3) 
0AA2:  MOVF   2E,W
0AA3:  SUBLW  03
0AA4:  BTFSS  03.2
0AA5:  GOTO   2B2
....................       { 
....................          OUTPUT_HIGH(vida1); 
0AA6:  BSF    03.5
0AA7:  BCF    06.2
0AA8:  BCF    03.5
0AA9:  BSF    06.2
....................          OUTPUT_HIGH(vida2); 
0AAA:  BSF    03.5
0AAB:  BCF    06.3
0AAC:  BCF    03.5
0AAD:  BSF    06.3
....................          OUTPUT_HIGH(vida3); 
0AAE:  BSF    03.5
0AAF:  BCF    06.4
0AB0:  BCF    03.5
0AB1:  BSF    06.4
....................       } 
....................  
....................       if (vida == 2) 
0AB2:  MOVF   2E,W
0AB3:  SUBLW  02
0AB4:  BTFSS  03.2
0AB5:  GOTO   2C2
....................       { 
....................          OUTPUT_HIGH(vida1); 
0AB6:  BSF    03.5
0AB7:  BCF    06.2
0AB8:  BCF    03.5
0AB9:  BSF    06.2
....................          OUTPUT_HIGH(vida2); 
0ABA:  BSF    03.5
0ABB:  BCF    06.3
0ABC:  BCF    03.5
0ABD:  BSF    06.3
....................          OUTPUT_LOW(vida3); 
0ABE:  BSF    03.5
0ABF:  BCF    06.4
0AC0:  BCF    03.5
0AC1:  BCF    06.4
....................       } 
....................       if (vida == 1) 
0AC2:  DECFSZ 2E,W
0AC3:  GOTO   2D0
....................       { 
....................          OUTPUT_HIGH(vida1); 
0AC4:  BSF    03.5
0AC5:  BCF    06.2
0AC6:  BCF    03.5
0AC7:  BSF    06.2
....................          OUTPUT_LOW(vida2); 
0AC8:  BSF    03.5
0AC9:  BCF    06.3
0ACA:  BCF    03.5
0ACB:  BCF    06.3
....................          OUTPUT_LOW(vida3); 
0ACC:  BSF    03.5
0ACD:  BCF    06.4
0ACE:  BCF    03.5
0ACF:  BCF    06.4
....................       } 
....................  
....................       if (vida == 0) 
0AD0:  MOVF   2E,F
0AD1:  BTFSS  03.2
0AD2:  GOTO   2DF
....................       { 
....................          OUTPUT_LOW(vida1); 
0AD3:  BSF    03.5
0AD4:  BCF    06.2
0AD5:  BCF    03.5
0AD6:  BCF    06.2
....................          OUTPUT_LOW(vida2); 
0AD7:  BSF    03.5
0AD8:  BCF    06.3
0AD9:  BCF    03.5
0ADA:  BCF    06.3
....................          OUTPUT_LOW(vida3); 
0ADB:  BSF    03.5
0ADC:  BCF    06.4
0ADD:  BCF    03.5
0ADE:  BCF    06.4
....................       } 
....................  
....................       if (input(button) == 1) 
0ADF:  BSF    03.5
0AE0:  BSF    06.0
0AE1:  BCF    03.5
0AE2:  BTFSS  06.0
0AE3:  GOTO   2FC
....................       { 
....................          if (st == 0) 
0AE4:  MOVF   2A,F
0AE5:  BTFSS  03.2
0AE6:  GOTO   2F3
....................          { 
....................             generate_tone(buzzer, 800, 128); 
0AE7:  MOVLW  31
0AE8:  MOVWF  2F
0AE9:  MOVLW  03
0AEA:  MOVWF  31
0AEB:  MOVLW  20
0AEC:  MOVWF  30
0AED:  CLRF   33
0AEE:  MOVLW  80
0AEF:  MOVWF  32
0AF0:  BCF    0A.3
0AF1:  CALL   3B3
0AF2:  BSF    0A.3
....................          } 
....................          dp = 1; 
0AF3:  BSF    29.0
....................          st++; 
0AF4:  INCF   2A,F
....................          if (st > 4) 
0AF5:  MOVF   2A,W
0AF6:  SUBLW  04
0AF7:  BTFSC  03.0
0AF8:  GOTO   2FB
....................          { 
....................             dp = 0; 
0AF9:  BCF    29.0
....................             st = 0; 
0AFA:  CLRF   2A
....................          } 
....................       } 
0AFB:  GOTO   2FE
....................       else 
....................       { 
....................          dp = 0; 
0AFC:  BCF    29.0
....................          st = 0; 
0AFD:  CLRF   2A
....................       } 
....................  
....................       if (pas == 0) 
0AFE:  BTFSC  29.1
0AFF:  GOTO   313
....................       { 
....................          dino1(2, dp); 
0B00:  MOVLW  00
0B01:  BTFSC  29.0
0B02:  MOVLW  01
0B03:  MOVWF  2F
0B04:  MOVLW  02
0B05:  MOVWF  30
0B06:  MOVF   2F,W
0B07:  MOVWF  31
0B08:  BCF    0A.3
0B09:  CALL   289
0B0A:  BSF    0A.3
....................          pas = 1; 
0B0B:  BSF    29.1
....................          sole1(1, 1); 
0B0C:  MOVLW  01
0B0D:  MOVWF  2F
0B0E:  MOVWF  30
0B0F:  BCF    0A.3
0B10:  GOTO   53F
0B11:  BSF    0A.3
....................       } 
0B12:  GOTO   325
....................       else 
....................       { 
....................          dino2(2, dp); 
0B13:  MOVLW  00
0B14:  BTFSC  29.0
0B15:  MOVLW  01
0B16:  MOVWF  2F
0B17:  MOVLW  02
0B18:  MOVWF  30
0B19:  MOVF   2F,W
0B1A:  MOVWF  31
0B1B:  BCF    0A.3
0B1C:  CALL   2A7
0B1D:  BSF    0A.3
....................          pas = 0; 
0B1E:  BCF    29.1
....................          sole2(1, 1); 
0B1F:  MOVLW  01
0B20:  MOVWF  2F
0B21:  MOVWF  30
0B22:  BCF    0A.3
0B23:  GOTO   55D
0B24:  BSF    0A.3
....................       } 
....................  
....................       if (random >= 0 && random < 10) 
0B25:  MOVF   28,W
0B26:  SUBLW  09
0B27:  BTFSS  03.0
0B28:  GOTO   412
....................       { 
....................          ///------------------comienza el juego con un solo captus------------------------------------------------------------------------------------------ 
....................          cact1(cuen, 2); 
0B29:  MOVF   2B,W
0B2A:  MOVWF  30
0B2B:  MOVLW  02
0B2C:  MOVWF  31
0B2D:  BCF    0A.3
0B2E:  CALL   57B
0B2F:  BSF    0A.3
....................  
....................          vel_juego(); 
0B30:  BCF    0A.3
0B31:  CALL   597
0B32:  BSF    0A.3
....................  
....................          //--------------------------------------------Condicion de fin de juego--------------------------------------------- 
....................          cuen--; 
0B33:  DECF   2B,F
....................          if (cuen == 2 && dp == 0) 
0B34:  MOVF   2B,W
0B35:  SUBLW  02
0B36:  BTFSS  03.2
0B37:  GOTO   3EE
0B38:  BTFSC  29.0
0B39:  GOTO   3EE
....................          { 
....................             if (vida == 0) 
0B3A:  MOVF   2E,F
0B3B:  BTFSS  03.2
0B3C:  GOTO   3C7
....................             { 
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0B3D:  MOVLW  31
0B3E:  MOVWF  2F
0B3F:  MOVLW  01
0B40:  MOVWF  31
0B41:  MOVLW  90
0B42:  MOVWF  30
0B43:  CLRF   33
0B44:  MOVLW  96
0B45:  MOVWF  32
0B46:  BCF    0A.3
0B47:  CALL   3B3
0B48:  BSF    0A.3
....................                delay_ms(500); 
0B49:  MOVLW  02
0B4A:  MOVWF  2F
0B4B:  MOVLW  FA
0B4C:  MOVWF  47
0B4D:  BCF    0A.3
0B4E:  CALL   0BB
0B4F:  BSF    0A.3
0B50:  DECFSZ 2F,F
0B51:  GOTO   34B
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0B52:  MOVLW  31
0B53:  MOVWF  2F
0B54:  MOVLW  01
0B55:  MOVWF  31
0B56:  MOVLW  90
0B57:  MOVWF  30
0B58:  CLRF   33
0B59:  MOVLW  96
0B5A:  MOVWF  32
0B5B:  BCF    0A.3
0B5C:  CALL   3B3
0B5D:  BSF    0A.3
....................                delay_ms(500); 
0B5E:  MOVLW  02
0B5F:  MOVWF  2F
0B60:  MOVLW  FA
0B61:  MOVWF  47
0B62:  BCF    0A.3
0B63:  CALL   0BB
0B64:  BSF    0A.3
0B65:  DECFSZ 2F,F
0B66:  GOTO   360
....................                generate_tone(buzzer, 150, 300); /// Reproduce sonido 
0B67:  MOVLW  31
0B68:  MOVWF  2F
0B69:  CLRF   31
0B6A:  MOVLW  96
0B6B:  MOVWF  30
0B6C:  MOVLW  01
0B6D:  MOVWF  33
0B6E:  MOVLW  2C
0B6F:  MOVWF  32
0B70:  BCF    0A.3
0B71:  CALL   3B3
0B72:  BSF    0A.3
....................                delay_ms(500); 
0B73:  MOVLW  02
0B74:  MOVWF  2F
0B75:  MOVLW  FA
0B76:  MOVWF  47
0B77:  BCF    0A.3
0B78:  CALL   0BB
0B79:  BSF    0A.3
0B7A:  DECFSZ 2F,F
0B7B:  GOTO   375
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0B7C:  MOVLW  01
0B7D:  MOVWF  3B
0B7E:  MOVWF  3C
0B7F:  BCF    0A.3
0B80:  CALL   1CE
0B81:  BSF    0A.3
....................                lcd_putc("uy x.x se murio "); 
0B82:  MOVLW  67
0B83:  BSF    03.6
0B84:  MOVWF  0D
0B85:  MOVLW  00
0B86:  MOVWF  0F
0B87:  BCF    0A.3
0B88:  BCF    03.6
0B89:  CALL   20C
0B8A:  BSF    0A.3
....................                delay_ms(2000); 
0B8B:  MOVLW  08
0B8C:  MOVWF  2F
0B8D:  MOVLW  FA
0B8E:  MOVWF  47
0B8F:  BCF    0A.3
0B90:  CALL   0BB
0B91:  BSF    0A.3
0B92:  DECFSZ 2F,F
0B93:  GOTO   38D
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0B94:  MOVLW  01
0B95:  MOVWF  3B
0B96:  MOVWF  3C
0B97:  BCF    0A.3
0B98:  CALL   1CE
0B99:  BSF    0A.3
....................                lcd_putc("tus pts perrooo!"); 
0B9A:  MOVLW  70
0B9B:  BSF    03.6
0B9C:  MOVWF  0D
0B9D:  MOVLW  00
0B9E:  MOVWF  0F
0B9F:  BCF    0A.3
0BA0:  BCF    03.6
0BA1:  CALL   20C
0BA2:  BSF    0A.3
....................                lcd_gotoxy(5, 2); // ubicamos cursor 
0BA3:  MOVLW  05
0BA4:  MOVWF  3B
0BA5:  MOVLW  02
0BA6:  MOVWF  3C
0BA7:  BCF    0A.3
0BA8:  CALL   1CE
0BA9:  BSF    0A.3
....................                printf(lcd_putc "p=" 
....................                                "%ld", 
....................                       sr); 
0BAA:  MOVLW  70
0BAB:  MOVWF  3A
0BAC:  BCF    0A.3
0BAD:  CALL   1E0
0BAE:  BSF    0A.3
0BAF:  MOVLW  3D
0BB0:  MOVWF  3A
0BB1:  BCF    0A.3
0BB2:  CALL   1E0
0BB3:  BSF    0A.3
0BB4:  MOVLW  10
0BB5:  MOVWF  04
0BB6:  MOVF   2D,W
0BB7:  MOVWF  30
0BB8:  MOVF   2C,W
0BB9:  MOVWF  2F
0BBA:  BCF    0A.3
0BBB:  CALL   4BF
0BBC:  BSF    0A.3
....................                delay_ms(4000); /// y se resetea el pic despues de un segundo 
0BBD:  MOVLW  10
0BBE:  MOVWF  2F
0BBF:  MOVLW  FA
0BC0:  MOVWF  47
0BC1:  BCF    0A.3
0BC2:  CALL   0BB
0BC3:  BSF    0A.3
0BC4:  DECFSZ 2F,F
0BC5:  GOTO   3BF
....................                goto menu; 
0BC6:  GOTO   0DF
....................             } 
....................             generate_tone(buzzer, 500, 80); /// Reproduce sonido 
0BC7:  MOVLW  31
0BC8:  MOVWF  2F
0BC9:  MOVLW  01
0BCA:  MOVWF  31
0BCB:  MOVLW  F4
0BCC:  MOVWF  30
0BCD:  CLRF   33
0BCE:  MOVLW  50
0BCF:  MOVWF  32
0BD0:  BCF    0A.3
0BD1:  CALL   3B3
0BD2:  BSF    0A.3
....................             vida--; 
0BD3:  DECF   2E,F
....................             cuen = 19; 
0BD4:  MOVLW  13
0BD5:  MOVWF  2B
....................             lcd_gotoxy(1, 1); // ubicamos cursor 
0BD6:  MOVLW  01
0BD7:  MOVWF  3B
0BD8:  MOVWF  3C
0BD9:  BCF    0A.3
0BDA:  CALL   1CE
0BDB:  BSF    0A.3
....................             lcd_putc("  uy!   -1  vida"); 
0BDC:  MOVLW  79
0BDD:  BSF    03.6
0BDE:  MOVWF  0D
0BDF:  MOVLW  00
0BE0:  MOVWF  0F
0BE1:  BCF    0A.3
0BE2:  BCF    03.6
0BE3:  CALL   20C
0BE4:  BSF    0A.3
....................             delay_ms(1000); 
0BE5:  MOVLW  04
0BE6:  MOVWF  2F
0BE7:  MOVLW  FA
0BE8:  MOVWF  47
0BE9:  BCF    0A.3
0BEA:  CALL   0BB
0BEB:  BSF    0A.3
0BEC:  DECFSZ 2F,F
0BED:  GOTO   3E7
....................          } 
....................  
....................          if (cuen == 0) 
0BEE:  MOVF   2B,F
0BEF:  BTFSS  03.2
0BF0:  GOTO   409
....................          { 
....................             cuen = 19; 
0BF1:  MOVLW  13
0BF2:  MOVWF  2B
....................             sr++; 
0BF3:  INCF   2C,F
0BF4:  BTFSC  03.2
0BF5:  INCF   2D,F
....................             random = rand() % 31; 
0BF6:  BCF    0A.3
0BF7:  CALL   5F0
0BF8:  BSF    0A.3
0BF9:  MOVF   79,W
0BFA:  MOVWF  30
0BFB:  MOVF   78,W
0BFC:  MOVWF  2F
0BFD:  MOVF   30,W
0BFE:  MOVWF  43
0BFF:  MOVF   2F,W
0C00:  MOVWF  42
0C01:  CLRF   45
0C02:  MOVLW  1F
0C03:  MOVWF  44
0C04:  BCF    0A.3
0C05:  CALL   314
0C06:  BSF    0A.3
0C07:  MOVF   77,W
0C08:  MOVWF  28
....................          } 
....................          lcd_putc("\f"); 
0C09:  MOVLW  82
0C0A:  BSF    03.6
0C0B:  MOVWF  0D
0C0C:  MOVLW  00
0C0D:  MOVWF  0F
0C0E:  BCF    0A.3
0C0F:  BCF    03.6
0C10:  CALL   20C
0C11:  BSF    0A.3
....................       } // fin de primer captus 
....................  
....................       if (random >= 10 && random < 20) 
0C12:  MOVF   28,W
0C13:  SUBLW  09
0C14:  BTFSC  03.0
0C15:  GOTO   510
0C16:  MOVF   28,W
0C17:  SUBLW  13
0C18:  BTFSS  03.0
0C19:  GOTO   510
....................       { 
....................          ///------------------comienza el juego con dos captus------------------------------------------------------------------------------------------ 
....................          cact1(cuen, 2); 
0C1A:  MOVF   2B,W
0C1B:  MOVWF  30
0C1C:  MOVLW  02
0C1D:  MOVWF  31
0C1E:  BCF    0A.3
0C1F:  CALL   57B
0C20:  BSF    0A.3
....................          cact2(cuen - 1, 2); 
0C21:  MOVLW  01
0C22:  SUBWF  2B,W
0C23:  MOVWF  2F
0C24:  MOVWF  30
0C25:  MOVLW  02
0C26:  MOVWF  31
0C27:  BCF    0A.3
0C28:  CALL   62E
0C29:  BSF    0A.3
....................  
....................          vel_juego(); 
0C2A:  BCF    0A.3
0C2B:  CALL   597
0C2C:  BSF    0A.3
....................  
....................          //--------------------------------------------Condicion de fin de juego--------------------------------------------- 
....................          cuen--; 
0C2D:  DECF   2B,F
....................          if ((cuen == 1 && dp == 0) || (cuen == 2 && dp == 0)) /////si coinciden el dinosaurio y el cactus en la misma posicion el juego termina 
0C2E:  DECFSZ 2B,W
0C2F:  GOTO   432
0C30:  BTFSS  29.0
0C31:  GOTO   438
0C32:  MOVF   2B,W
0C33:  SUBLW  02
0C34:  BTFSS  03.2
0C35:  GOTO   4EC
0C36:  BTFSC  29.0
0C37:  GOTO   4EC
....................          { 
....................             if (vida == 0) 
0C38:  MOVF   2E,F
0C39:  BTFSS  03.2
0C3A:  GOTO   4C5
....................             { 
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0C3B:  MOVLW  31
0C3C:  MOVWF  2F
0C3D:  MOVLW  01
0C3E:  MOVWF  31
0C3F:  MOVLW  90
0C40:  MOVWF  30
0C41:  CLRF   33
0C42:  MOVLW  96
0C43:  MOVWF  32
0C44:  BCF    0A.3
0C45:  CALL   3B3
0C46:  BSF    0A.3
....................                delay_ms(500); 
0C47:  MOVLW  02
0C48:  MOVWF  2F
0C49:  MOVLW  FA
0C4A:  MOVWF  47
0C4B:  BCF    0A.3
0C4C:  CALL   0BB
0C4D:  BSF    0A.3
0C4E:  DECFSZ 2F,F
0C4F:  GOTO   449
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0C50:  MOVLW  31
0C51:  MOVWF  2F
0C52:  MOVLW  01
0C53:  MOVWF  31
0C54:  MOVLW  90
0C55:  MOVWF  30
0C56:  CLRF   33
0C57:  MOVLW  96
0C58:  MOVWF  32
0C59:  BCF    0A.3
0C5A:  CALL   3B3
0C5B:  BSF    0A.3
....................                delay_ms(500); 
0C5C:  MOVLW  02
0C5D:  MOVWF  2F
0C5E:  MOVLW  FA
0C5F:  MOVWF  47
0C60:  BCF    0A.3
0C61:  CALL   0BB
0C62:  BSF    0A.3
0C63:  DECFSZ 2F,F
0C64:  GOTO   45E
....................                generate_tone(buzzer, 150, 300); /// Reproduce sonido 
0C65:  MOVLW  31
0C66:  MOVWF  2F
0C67:  CLRF   31
0C68:  MOVLW  96
0C69:  MOVWF  30
0C6A:  MOVLW  01
0C6B:  MOVWF  33
0C6C:  MOVLW  2C
0C6D:  MOVWF  32
0C6E:  BCF    0A.3
0C6F:  CALL   3B3
0C70:  BSF    0A.3
....................                delay_ms(500); 
0C71:  MOVLW  02
0C72:  MOVWF  2F
0C73:  MOVLW  FA
0C74:  MOVWF  47
0C75:  BCF    0A.3
0C76:  CALL   0BB
0C77:  BSF    0A.3
0C78:  DECFSZ 2F,F
0C79:  GOTO   473
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0C7A:  MOVLW  01
0C7B:  MOVWF  3B
0C7C:  MOVWF  3C
0C7D:  BCF    0A.3
0C7E:  CALL   1CE
0C7F:  BSF    0A.3
....................                lcd_putc("uy x.x se murio "); 
0C80:  MOVLW  83
0C81:  BSF    03.6
0C82:  MOVWF  0D
0C83:  MOVLW  00
0C84:  MOVWF  0F
0C85:  BCF    0A.3
0C86:  BCF    03.6
0C87:  CALL   20C
0C88:  BSF    0A.3
....................                delay_ms(2000); 
0C89:  MOVLW  08
0C8A:  MOVWF  2F
0C8B:  MOVLW  FA
0C8C:  MOVWF  47
0C8D:  BCF    0A.3
0C8E:  CALL   0BB
0C8F:  BSF    0A.3
0C90:  DECFSZ 2F,F
0C91:  GOTO   48B
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0C92:  MOVLW  01
0C93:  MOVWF  3B
0C94:  MOVWF  3C
0C95:  BCF    0A.3
0C96:  CALL   1CE
0C97:  BSF    0A.3
....................                lcd_putc("tus pts perrooo!"); 
0C98:  MOVLW  8C
0C99:  BSF    03.6
0C9A:  MOVWF  0D
0C9B:  MOVLW  00
0C9C:  MOVWF  0F
0C9D:  BCF    0A.3
0C9E:  BCF    03.6
0C9F:  CALL   20C
0CA0:  BSF    0A.3
....................                lcd_gotoxy(5, 2); // ubicamos cursor 
0CA1:  MOVLW  05
0CA2:  MOVWF  3B
0CA3:  MOVLW  02
0CA4:  MOVWF  3C
0CA5:  BCF    0A.3
0CA6:  CALL   1CE
0CA7:  BSF    0A.3
....................                printf(lcd_putc "p=" 
....................                                "%ld", 
....................                       sr); 
0CA8:  MOVLW  70
0CA9:  MOVWF  3A
0CAA:  BCF    0A.3
0CAB:  CALL   1E0
0CAC:  BSF    0A.3
0CAD:  MOVLW  3D
0CAE:  MOVWF  3A
0CAF:  BCF    0A.3
0CB0:  CALL   1E0
0CB1:  BSF    0A.3
0CB2:  MOVLW  10
0CB3:  MOVWF  04
0CB4:  MOVF   2D,W
0CB5:  MOVWF  30
0CB6:  MOVF   2C,W
0CB7:  MOVWF  2F
0CB8:  BCF    0A.3
0CB9:  CALL   4BF
0CBA:  BSF    0A.3
....................                delay_ms(4000); /// y se resetea el pic despues de un segundo 
0CBB:  MOVLW  10
0CBC:  MOVWF  2F
0CBD:  MOVLW  FA
0CBE:  MOVWF  47
0CBF:  BCF    0A.3
0CC0:  CALL   0BB
0CC1:  BSF    0A.3
0CC2:  DECFSZ 2F,F
0CC3:  GOTO   4BD
....................                goto menu; 
0CC4:  GOTO   0DF
....................             } 
....................             generate_tone(buzzer, 500, 80); /// Reproduce sonido 
0CC5:  MOVLW  31
0CC6:  MOVWF  2F
0CC7:  MOVLW  01
0CC8:  MOVWF  31
0CC9:  MOVLW  F4
0CCA:  MOVWF  30
0CCB:  CLRF   33
0CCC:  MOVLW  50
0CCD:  MOVWF  32
0CCE:  BCF    0A.3
0CCF:  CALL   3B3
0CD0:  BSF    0A.3
....................             vida--; 
0CD1:  DECF   2E,F
....................             cuen = 19; 
0CD2:  MOVLW  13
0CD3:  MOVWF  2B
....................             lcd_gotoxy(1, 1); // ubicamos cursor 
0CD4:  MOVLW  01
0CD5:  MOVWF  3B
0CD6:  MOVWF  3C
0CD7:  BCF    0A.3
0CD8:  CALL   1CE
0CD9:  BSF    0A.3
....................             lcd_putc("  uy!   -1  vida"); 
0CDA:  MOVLW  95
0CDB:  BSF    03.6
0CDC:  MOVWF  0D
0CDD:  MOVLW  00
0CDE:  MOVWF  0F
0CDF:  BCF    0A.3
0CE0:  BCF    03.6
0CE1:  CALL   20C
0CE2:  BSF    0A.3
....................             delay_ms(1000); 
0CE3:  MOVLW  04
0CE4:  MOVWF  2F
0CE5:  MOVLW  FA
0CE6:  MOVWF  47
0CE7:  BCF    0A.3
0CE8:  CALL   0BB
0CE9:  BSF    0A.3
0CEA:  DECFSZ 2F,F
0CEB:  GOTO   4E5
....................          } 
....................  
....................          if (cuen == 0) 
0CEC:  MOVF   2B,F
0CED:  BTFSS  03.2
0CEE:  GOTO   507
....................          { 
....................             cuen = 19; 
0CEF:  MOVLW  13
0CF0:  MOVWF  2B
....................             sr++; 
0CF1:  INCF   2C,F
0CF2:  BTFSC  03.2
0CF3:  INCF   2D,F
....................             random = rand() % 31; 
0CF4:  BCF    0A.3
0CF5:  CALL   5F0
0CF6:  BSF    0A.3
0CF7:  MOVF   79,W
0CF8:  MOVWF  30
0CF9:  MOVF   78,W
0CFA:  MOVWF  2F
0CFB:  MOVF   30,W
0CFC:  MOVWF  43
0CFD:  MOVF   2F,W
0CFE:  MOVWF  42
0CFF:  CLRF   45
0D00:  MOVLW  1F
0D01:  MOVWF  44
0D02:  BCF    0A.3
0D03:  CALL   314
0D04:  BSF    0A.3
0D05:  MOVF   77,W
0D06:  MOVWF  28
....................          } 
....................          lcd_putc("\f"); 
0D07:  MOVLW  9E
0D08:  BSF    03.6
0D09:  MOVWF  0D
0D0A:  MOVLW  00
0D0B:  MOVWF  0F
0D0C:  BCF    0A.3
0D0D:  BCF    03.6
0D0E:  CALL   20C
0D0F:  BSF    0A.3
....................       } // fin de primer captus 
....................  
....................       if (random >=20) 
0D10:  MOVF   28,W
0D11:  SUBLW  13
0D12:  BTFSC  03.0
0D13:  GOTO   619
....................       { 
....................          ///------------------comienza el juego------------------------------------------------------------------------------------------ 
....................          cact1(cuen - 1, 2); 
0D14:  MOVLW  01
0D15:  SUBWF  2B,W
0D16:  MOVWF  2F
0D17:  MOVWF  30
0D18:  MOVLW  02
0D19:  MOVWF  31
0D1A:  BCF    0A.3
0D1B:  CALL   57B
0D1C:  BSF    0A.3
....................          cact2(cuen - 2, 2); 
0D1D:  MOVLW  02
0D1E:  SUBWF  2B,W
0D1F:  MOVWF  2F
0D20:  MOVWF  30
0D21:  MOVLW  02
0D22:  MOVWF  31
0D23:  BCF    0A.3
0D24:  CALL   62E
0D25:  BSF    0A.3
....................          cact1(cuen, 2); 
0D26:  MOVF   2B,W
0D27:  MOVWF  30
0D28:  MOVLW  02
0D29:  MOVWF  31
0D2A:  BCF    0A.3
0D2B:  CALL   57B
0D2C:  BSF    0A.3
....................  
....................          vel_juego(); 
0D2D:  BCF    0A.3
0D2E:  CALL   597
0D2F:  BSF    0A.3
....................  
....................          //--------------------------------------------Condicion de fin de juego--------------------------------------------- 
....................          cuen--; 
0D30:  DECF   2B,F
....................          if ((cuen == 1 && dp == 0) || (cuen == 2 && dp == 0) || 
....................              (cuen == 3 && dp == 0)) /////si coinciden el dinosaurio y el cactus en la misma posicion el juego termina 
0D31:  DECFSZ 2B,W
0D32:  GOTO   535
0D33:  BTFSS  29.0
0D34:  GOTO   541
0D35:  MOVF   2B,W
0D36:  SUBLW  02
0D37:  BTFSS  03.2
0D38:  GOTO   53B
0D39:  BTFSS  29.0
0D3A:  GOTO   541
0D3B:  MOVF   2B,W
0D3C:  SUBLW  03
0D3D:  BTFSS  03.2
0D3E:  GOTO   5F5
0D3F:  BTFSC  29.0
0D40:  GOTO   5F5
....................          { 
....................             if (vida == 0) 
0D41:  MOVF   2E,F
0D42:  BTFSS  03.2
0D43:  GOTO   5CE
....................             { 
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0D44:  MOVLW  31
0D45:  MOVWF  2F
0D46:  MOVLW  01
0D47:  MOVWF  31
0D48:  MOVLW  90
0D49:  MOVWF  30
0D4A:  CLRF   33
0D4B:  MOVLW  96
0D4C:  MOVWF  32
0D4D:  BCF    0A.3
0D4E:  CALL   3B3
0D4F:  BSF    0A.3
....................                delay_ms(500); 
0D50:  MOVLW  02
0D51:  MOVWF  2F
0D52:  MOVLW  FA
0D53:  MOVWF  47
0D54:  BCF    0A.3
0D55:  CALL   0BB
0D56:  BSF    0A.3
0D57:  DECFSZ 2F,F
0D58:  GOTO   552
....................                generate_tone(buzzer, 400, 150); /// Reproduce sonido 
0D59:  MOVLW  31
0D5A:  MOVWF  2F
0D5B:  MOVLW  01
0D5C:  MOVWF  31
0D5D:  MOVLW  90
0D5E:  MOVWF  30
0D5F:  CLRF   33
0D60:  MOVLW  96
0D61:  MOVWF  32
0D62:  BCF    0A.3
0D63:  CALL   3B3
0D64:  BSF    0A.3
....................                delay_ms(500); 
0D65:  MOVLW  02
0D66:  MOVWF  2F
0D67:  MOVLW  FA
0D68:  MOVWF  47
0D69:  BCF    0A.3
0D6A:  CALL   0BB
0D6B:  BSF    0A.3
0D6C:  DECFSZ 2F,F
0D6D:  GOTO   567
....................                generate_tone(buzzer, 150, 300); /// Reproduce sonido 
0D6E:  MOVLW  31
0D6F:  MOVWF  2F
0D70:  CLRF   31
0D71:  MOVLW  96
0D72:  MOVWF  30
0D73:  MOVLW  01
0D74:  MOVWF  33
0D75:  MOVLW  2C
0D76:  MOVWF  32
0D77:  BCF    0A.3
0D78:  CALL   3B3
0D79:  BSF    0A.3
....................                delay_ms(500); 
0D7A:  MOVLW  02
0D7B:  MOVWF  2F
0D7C:  MOVLW  FA
0D7D:  MOVWF  47
0D7E:  BCF    0A.3
0D7F:  CALL   0BB
0D80:  BSF    0A.3
0D81:  DECFSZ 2F,F
0D82:  GOTO   57C
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0D83:  MOVLW  01
0D84:  MOVWF  3B
0D85:  MOVWF  3C
0D86:  BCF    0A.3
0D87:  CALL   1CE
0D88:  BSF    0A.3
....................                lcd_putc("uy x.x se murio "); 
0D89:  MOVLW  9F
0D8A:  BSF    03.6
0D8B:  MOVWF  0D
0D8C:  MOVLW  00
0D8D:  MOVWF  0F
0D8E:  BCF    0A.3
0D8F:  BCF    03.6
0D90:  CALL   20C
0D91:  BSF    0A.3
....................                delay_ms(2000); 
0D92:  MOVLW  08
0D93:  MOVWF  2F
0D94:  MOVLW  FA
0D95:  MOVWF  47
0D96:  BCF    0A.3
0D97:  CALL   0BB
0D98:  BSF    0A.3
0D99:  DECFSZ 2F,F
0D9A:  GOTO   594
....................                lcd_gotoxy(1, 1); // ubicamos cursor 
0D9B:  MOVLW  01
0D9C:  MOVWF  3B
0D9D:  MOVWF  3C
0D9E:  BCF    0A.3
0D9F:  CALL   1CE
0DA0:  BSF    0A.3
....................                lcd_putc("tus pts perrooo!"); 
0DA1:  MOVLW  A8
0DA2:  BSF    03.6
0DA3:  MOVWF  0D
0DA4:  MOVLW  00
0DA5:  MOVWF  0F
0DA6:  BCF    0A.3
0DA7:  BCF    03.6
0DA8:  CALL   20C
0DA9:  BSF    0A.3
....................                lcd_gotoxy(5, 2); // ubicamos cursor 
0DAA:  MOVLW  05
0DAB:  MOVWF  3B
0DAC:  MOVLW  02
0DAD:  MOVWF  3C
0DAE:  BCF    0A.3
0DAF:  CALL   1CE
0DB0:  BSF    0A.3
....................                printf(lcd_putc "p=" 
....................                                "%ld", 
....................                       sr); 
0DB1:  MOVLW  70
0DB2:  MOVWF  3A
0DB3:  BCF    0A.3
0DB4:  CALL   1E0
0DB5:  BSF    0A.3
0DB6:  MOVLW  3D
0DB7:  MOVWF  3A
0DB8:  BCF    0A.3
0DB9:  CALL   1E0
0DBA:  BSF    0A.3
0DBB:  MOVLW  10
0DBC:  MOVWF  04
0DBD:  MOVF   2D,W
0DBE:  MOVWF  30
0DBF:  MOVF   2C,W
0DC0:  MOVWF  2F
0DC1:  BCF    0A.3
0DC2:  CALL   4BF
0DC3:  BSF    0A.3
....................                delay_ms(4000); /// y se resetea el pic despues de un segundo 
0DC4:  MOVLW  10
0DC5:  MOVWF  2F
0DC6:  MOVLW  FA
0DC7:  MOVWF  47
0DC8:  BCF    0A.3
0DC9:  CALL   0BB
0DCA:  BSF    0A.3
0DCB:  DECFSZ 2F,F
0DCC:  GOTO   5C6
....................                goto menu; 
0DCD:  GOTO   0DF
....................             } 
....................             generate_tone(buzzer, 500, 80); /// Reproduce sonido 
0DCE:  MOVLW  31
0DCF:  MOVWF  2F
0DD0:  MOVLW  01
0DD1:  MOVWF  31
0DD2:  MOVLW  F4
0DD3:  MOVWF  30
0DD4:  CLRF   33
0DD5:  MOVLW  50
0DD6:  MOVWF  32
0DD7:  BCF    0A.3
0DD8:  CALL   3B3
0DD9:  BSF    0A.3
....................             vida--; 
0DDA:  DECF   2E,F
....................             cuen = 19; 
0DDB:  MOVLW  13
0DDC:  MOVWF  2B
....................             lcd_gotoxy(1, 1); // ubicamos cursor 
0DDD:  MOVLW  01
0DDE:  MOVWF  3B
0DDF:  MOVWF  3C
0DE0:  BCF    0A.3
0DE1:  CALL   1CE
0DE2:  BSF    0A.3
....................             lcd_putc("  uy!   -1  vida"); 
0DE3:  MOVLW  B1
0DE4:  BSF    03.6
0DE5:  MOVWF  0D
0DE6:  MOVLW  00
0DE7:  MOVWF  0F
0DE8:  BCF    0A.3
0DE9:  BCF    03.6
0DEA:  CALL   20C
0DEB:  BSF    0A.3
....................             delay_ms(1000); 
0DEC:  MOVLW  04
0DED:  MOVWF  2F
0DEE:  MOVLW  FA
0DEF:  MOVWF  47
0DF0:  BCF    0A.3
0DF1:  CALL   0BB
0DF2:  BSF    0A.3
0DF3:  DECFSZ 2F,F
0DF4:  GOTO   5EE
....................          } 
....................  
....................          if (cuen == 0) 
0DF5:  MOVF   2B,F
0DF6:  BTFSS  03.2
0DF7:  GOTO   610
....................          { 
....................             cuen = 19; 
0DF8:  MOVLW  13
0DF9:  MOVWF  2B
....................             sr++; 
0DFA:  INCF   2C,F
0DFB:  BTFSC  03.2
0DFC:  INCF   2D,F
....................             random = rand() % 31; 
0DFD:  BCF    0A.3
0DFE:  CALL   5F0
0DFF:  BSF    0A.3
0E00:  MOVF   79,W
0E01:  MOVWF  30
0E02:  MOVF   78,W
0E03:  MOVWF  2F
0E04:  MOVF   30,W
0E05:  MOVWF  43
0E06:  MOVF   2F,W
0E07:  MOVWF  42
0E08:  CLRF   45
0E09:  MOVLW  1F
0E0A:  MOVWF  44
0E0B:  BCF    0A.3
0E0C:  CALL   314
0E0D:  BSF    0A.3
0E0E:  MOVF   77,W
0E0F:  MOVWF  28
....................          } 
....................  
....................          lcd_putc("\f"); 
0E10:  MOVLW  BA
0E11:  BSF    03.6
0E12:  MOVWF  0D
0E13:  MOVLW  00
0E14:  MOVWF  0F
0E15:  BCF    0A.3
0E16:  BCF    03.6
0E17:  CALL   20C
0E18:  BSF    0A.3
....................       } // fin de primer captus 
0E19:  GOTO   282
....................  
....................    } // FIN DEL CICLO 
....................  
.................... } // fin de main 
0E1A:  SLEEP

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
